<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="多线程," />





  <link rel="alternate" href="/atom.xml" title="dijia478-刘力源" type="application/atom+xml" />






<meta name="description" content="什么是线程？ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。">
<meta name="keywords" content="多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程相关问题汇总">
<meta property="og:url" content="http://dijia478.cn/blog/2015/12/23/2015-12-23-Java多线程相关问题汇总/index.html">
<meta property="og:site_name" content="dijia478-刘力源">
<meta property="og:description" content="什么是线程？ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-03T05:17:35.299Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程相关问题汇总">
<meta name="twitter:description" content="什么是线程？ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://dijia478.cn/blog/2015/12/23/2015-12-23-Java多线程相关问题汇总/"/>





  <title>Java多线程相关问题汇总 | dijia478-刘力源</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">dijia478-刘力源</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://dijia478.cn/blog/2015/12/23/2015-12-23-Java多线程相关问题汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dijia478">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dijia478-刘力源">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java多线程相关问题汇总</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-23T10:18:18+08:00">
                2015-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16,769
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><blockquote>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。</p>
</blockquote>
<a id="more"></a>
<h4 id="多线程有什么用？"><a href="#多线程有什么用？" class="headerlink" title="多线程有什么用？"></a>多线程有什么用？</h4><blockquote>
<ul>
<li><p>发挥多核CPU的优势<br>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p>
</li>
<li><p>防止阻塞<br>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p>
</li>
<li><p>便于建模<br>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p>
</li>
</ul>
<p>使用多线程的优势：<br>更多的处理器核心；更快的响应时间；更好的编程模型。</p>
</blockquote>
<h4 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h4><blockquote>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
</blockquote>
<h4 id="如何在Java中实现多线程？"><a href="#如何在Java中实现多线程？" class="headerlink" title="如何在Java中实现多线程？"></a>如何在Java中实现多线程？</h4><blockquote>
<p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程，但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类，或者直接实现Runnable接口来重写run方法实现线程。至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p>
</blockquote>
<h4 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h4><blockquote>
<p>这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。</p>
</blockquote>
<h4 id="Thread-类中的start和-run方法有什么区别？"><a href="#Thread-类中的start和-run方法有什么区别？" class="headerlink" title="Thread 类中的start和 run方法有什么区别？"></a>Thread 类中的start和 run方法有什么区别？</h4><blockquote>
<p>start方法被用来启动新创建的线程，只有调用了start方法，才会表现出多线程的特性，而且start内部调用了run方法，不同线程的run方法里面的代码交替执行，这和直接调用run方法的效果不一样。</p>
<p>当你调用run方法的时候，只会是在原来的线程中调用，没有新的线程启动，start方法才会启动新线程。如果只是调用run方法，那么代码还是同步执行的，必须等待一个线程的run方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run方法里面的代码。</p>
</blockquote>
<h4 id="Java中Runnable和Callable有什么不同？"><a href="#Java中Runnable和Callable有什么不同？" class="headerlink" title="Java中Runnable和Callable有什么不同？"></a>Java中Runnable和Callable有什么不同？</h4><blockquote>
<p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call方法可以返回值（是一个泛型）和抛出异常，返回装载有计算结果的Future对象。和Future、FutureTask配合可以用来获取多线程执行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。而Runnable接口中的run方法的返回值是void，它做的事情只是纯粹地去执行run方法中的代码而已。</p>
</blockquote>
<h4 id="Java中CyclicBarrier-和-CountDownLatch有什么不同？"><a href="#Java中CyclicBarrier-和-CountDownLatch有什么不同？" class="headerlink" title="Java中CyclicBarrier 和 CountDownLatch有什么不同？"></a>Java中CyclicBarrier 和 CountDownLatch有什么不同？</h4><blockquote>
<p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。</p>
<p>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p>
<p>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务<br>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p>
</blockquote>
<h4 id="Java中如何停止一个线程？"><a href="#Java中如何停止一个线程？" class="headerlink" title="Java中如何停止一个线程？"></a>Java中如何停止一个线程？</h4><blockquote>
<p>Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop, suspend和 resume的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run或者 call方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run方法的循环或者是取消任务来中断线程。</p>
</blockquote>
<h4 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h4><blockquote>
<p>简单的说，如果异常没有被捕获，该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException方法进行处理。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。</p>
</blockquote>
<h4 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h4><blockquote>
<p>你可以通过共享对象来实现这个目的，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待.或者是使用像阻塞队列这样并发的数据结构，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p>
</blockquote>
<h4 id="什么是线程安全？Vector是一个线程安全类吗？"><a href="#什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="什么是线程安全？Vector是一个线程安全类吗？"></a>什么是线程安全？Vector是一个线程安全类吗？</h4><blockquote>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。简单来说就是，如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p>
<ul>
<li><p>不可变<br>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>
</li>
<li><p>绝对线程安全<br>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p>
</li>
<li><p>相对线程安全<br>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p>
</li>
<li><p>线程非安全<br>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p>
</li>
</ul>
</blockquote>
<h4 id="如何强制启动一个线程？"><a href="#如何强制启动一个线程？" class="headerlink" title="如何强制启动一个线程？"></a>如何强制启动一个线程？</h4><blockquote>
<p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
</blockquote>
<h4 id="Java多线程中调用wait和-sleep方法有什么不同？"><a href="#Java多线程中调用wait和-sleep方法有什么不同？" class="headerlink" title="Java多线程中调用wait和 sleep方法有什么不同？"></a>Java多线程中调用wait和 sleep方法有什么不同？</h4><blockquote>
<p>Java程序中wait和sleep都可以用来放弃CPU一定的时间，都会造成某种形式的暂停。<br>wait方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁。<br>而sleep方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。<br>如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器。</p>
</blockquote>
<h4 id="Thread-sleep-0-的作用是什么？"><a href="#Thread-sleep-0-的作用是什么？" class="headerlink" title="Thread.sleep(0)的作用是什么？"></a>Thread.sleep(0)的作用是什么？</h4><blockquote>
<p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p>
</blockquote>
<h4 id="怎么唤醒一个阻塞的线程？"><a href="#怎么唤醒一个阻塞的线程？" class="headerlink" title="怎么唤醒一个阻塞的线程？"></a>怎么唤醒一个阻塞的线程？</h4><blockquote>
<p>如果线程是因为调用了wait、sleep或者join方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>
</blockquote>
<h4 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h4><blockquote>
<p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p>
</blockquote>
<h4 id="什么是线程池？-为什么要使用它？"><a href="#什么是线程池？-为什么要使用它？" class="headerlink" title="什么是线程池？ 为什么要使用它？"></a>什么是线程池？ 为什么要使用它？</h4><blockquote>
<p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p>
</blockquote>
<h4 id="如果你提交任务时，线程池队列已满，这时会发生什么？"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么？"></a>如果你提交任务时，线程池队列已满，这时会发生什么？</h4><blockquote>
<p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit方法将会抛出一个RejectedExecutionException异常。如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p>
</blockquote>
<h4 id="Java线程池中submit和-execute方法有什么区别？"><a href="#Java线程池中submit和-execute方法有什么区别？" class="headerlink" title="Java线程池中submit和 execute方法有什么区别？"></a>Java线程池中submit和 execute方法有什么区别？</h4><blockquote>
<p>两个方法都可以向线程池提交任务，execute方法的返回类型是void，它定义在Executor接口中, 而submit方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
</blockquote>
<h4 id="Java中用到的线程调度算法是什么？"><a href="#Java中用到的线程调度算法是什么？" class="headerlink" title="Java中用到的线程调度算法是什么？"></a>Java中用到的线程调度算法是什么？</h4><blockquote>
<p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
</blockquote>
<h4 id="Java内存模型是什么？"><a href="#Java内存模型是什么？" class="headerlink" title="Java内存模型是什么？"></a>Java内存模型是什么？</h4><blockquote>
<p>Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它定义了一种多线程访问Java内存的规范，在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。我简单总结一下Java内存模型的几部分内容：</p>
<ul>
<li>Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</li>
<li>定义了几个原子操作，用于操作主内存和工作内存中的变量</li>
<li>定义了volatile变量的使用规则</li>
<li>happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</li>
</ul>
<p>我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p>
</blockquote>
<h4 id="Java中的volatile-变量是什么？"><a href="#Java中的volatile-变量是什么？" class="headerlink" title="Java中的volatile 变量是什么？"></a>Java中的volatile 变量是什么？</h4><blockquote>
<p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。volatile关键字的作用主要有两个：</p>
<p>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据<br>代码底层执行不像我们看到的高级语言—Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率<br>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>
</blockquote>
<h4 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h4><blockquote>
<p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
</blockquote>
<h4 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的?"></a>线程类的构造方法、静态块是被哪个线程调用的?</h4><blockquote>
<p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。<br>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p>
<ul>
<li>Thread2的构造方法、静态块是main线程调用的，Thread2的run方法是Thread2自己调用的</li>
<li>Thread1的构造方法、静态块是Thread2调用的，Thread1的run方法是Thread1自己调用的</li>
</ul>
</blockquote>
<h4 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h4><blockquote>
<p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。</p>
</blockquote>
<h4 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h4><blockquote>
<ul>
<li>乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</li>
<li>悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</li>
</ul>
</blockquote>
<h4 id="什么是自旋？"><a href="#什么是自旋？" class="headerlink" title="什么是自旋？"></a>什么是自旋？</h4><blockquote>
<p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
</blockquote>
<h4 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h4><blockquote>
<p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p>
</blockquote>
<h4 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h4><blockquote>
<p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。<br>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。<br>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p>
</blockquote>
<h4 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h4><blockquote>
<p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p>
</blockquote>
<h4 id="什么是FutureTask？"><a href="#什么是FutureTask？" class="headerlink" title="什么是FutureTask？"></a>什么是FutureTask？</h4><blockquote>
<p>在Java并发程序中FutureTask表示一个可以取消的异步运算任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务进行启动和取消运算、查询运算是否完成和取回运算结果等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是实现了Runnable接口所以它可以提交给Executor线程池来执行。</p>
</blockquote>
<h4 id="不可变对象对多线程有什么帮助？"><a href="#不可变对象对多线程有什么帮助？" class="headerlink" title="不可变对象对多线程有什么帮助？"></a>不可变对象对多线程有什么帮助？</h4><blockquote>
<p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p>
</blockquote>
<h4 id="Java中什么是竞态条件？-举个例子说明。"><a href="#Java中什么是竞态条件？-举个例子说明。" class="headerlink" title="Java中什么是竞态条件？ 举个例子说明。"></a>Java中什么是竞态条件？ 举个例子说明。</h4><blockquote>
<p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理。</p>
</blockquote>
<h4 id="Java中notify-和-notifyAll有什么区别？"><a href="#Java中notify-和-notifyAll有什么区别？" class="headerlink" title="Java中notify 和 notifyAll有什么区别？"></a>Java中notify 和 notifyAll有什么区别？</h4><blockquote>
<p>这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p>
</blockquote>
<h4 id="为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><blockquote>
<p>这是个设计相关的问题，它考察的是程序员对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait方法就有意义了。如果wait方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
</blockquote>
<h4 id="wait-notify-notifyAll用法？"><a href="#wait-notify-notifyAll用法？" class="headerlink" title="wait, notify, notifyAll用法？"></a>wait, notify, notifyAll用法？</h4><blockquote>
<p>只能在同步方法或者同步块中使用wait()方法。在执行wait()方法后，当前线程释放锁（这点与sleep和yield方法不同）。调用了wait函数的线程会一直等待，知道有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立刻获得对象的锁，要等待执行notify()方法的线程执行完，即退出synchronized代码块后，当前线程才会释放锁，而呈wait状态的线程才可以获取该对象锁。<br>如果调用wait()方法时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕获异常。<br>notify方法只会（随机）唤醒一个正在等待的线程，而notifyAll方法会唤醒所有正在等待的线程。如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。<br>带参数的wait(long timeout)或者wait(long timeout, int nanos)方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。<br>注意，wait方法和notify/notifyAll方法要在同步块中调用，主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
</blockquote>
<h4 id="wait方法和notify-notifyAll方法在放弃对象监视器时有什么区别？"><a href="#wait方法和notify-notifyAll方法在放弃对象监视器时有什么区别？" class="headerlink" title="wait方法和notify/notifyAll方法在放弃对象监视器时有什么区别？"></a>wait方法和notify/notifyAll方法在放弃对象监视器时有什么区别？</h4><blockquote>
<p>wait方法立即释放对象监视器，notify/notifyAll方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p>
</blockquote>
<h4 id="多线程中的忙循环是什么"><a href="#多线程中的忙循环是什么" class="headerlink" title="多线程中的忙循环是什么?"></a>多线程中的忙循环是什么?</h4><blockquote>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait, sleep或 yield它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
</blockquote>
<h4 id="怎么检测一个线程是否持有对象监视器？"><a href="#怎么检测一个线程是否持有对象监视器？" class="headerlink" title="怎么检测一个线程是否持有对象监视器？"></a>怎么检测一个线程是否持有对象监视器？</h4><blockquote>
<p>我也是在网上看到一篇文章才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj.方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。</p>
</blockquote>
<h4 id="Java中interrupted-和-isInterruptedd方法的区别？"><a href="#Java中interrupted-和-isInterruptedd方法的区别？" class="headerlink" title="Java中interrupted 和 isInterruptedd方法的区别？"></a>Java中interrupted 和 isInterruptedd方法的区别？</h4><blockquote>
<p>interrupted和 isInterrupted的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
</blockquote>
<h4 id="为什么你应该在循环中检查等待条件"><a href="#为什么你应该在循环中检查等待条件" class="headerlink" title="为什么你应该在循环中检查等待条件?"></a>为什么你应该在循环中检查等待条件?</h4><blockquote>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
</blockquote>
<h4 id="Java中的同步集合与并发集合有什么区别？"><a href="#Java中的同步集合与并发集合有什么区别？" class="headerlink" title="Java中的同步集合与并发集合有什么区别？"></a>Java中的同步集合与并发集合有什么区别？</h4><blockquote>
<p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p>
</blockquote>
<h4 id="Java中ConcurrentHashMap的并发度是什么？"><a href="#Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="Java中ConcurrentHashMap的并发度是什么？"></a>Java中ConcurrentHashMap的并发度是什么？</h4><blockquote>
<p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数segment的大小，默认值为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这样在多线程情况下也能避免争用。这也是ConcurrentHashMap对Hashtable的最大优势，Hashtable不能同时有两条线程获取Hashtable中的数据。</p>
</blockquote>
<h4 id="Java中堆和栈有什么不同？"><a href="#Java中堆和栈有什么不同？" class="headerlink" title="Java中堆和栈有什么不同？"></a>Java中堆和栈有什么不同？</h4><blockquote>
<p>为什么把这个问题归类在多线程和并发里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
</blockquote>
<h4 id="生产者消费者模型的作用是什么？"><a href="#生产者消费者模型的作用是什么？" class="headerlink" title="生产者消费者模型的作用是什么？"></a>生产者消费者模型的作用是什么？</h4><blockquote>
<p>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p>
</blockquote>
<h4 id="如何写代码来解决生产者消费者问题？"><a href="#如何写代码来解决生产者消费者问题？" class="headerlink" title="如何写代码来解决生产者消费者问题？"></a>如何写代码来解决生产者消费者问题？</h4><blockquote>
<p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型。</p>
</blockquote>
<h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><blockquote>
<p>Java多线程中的死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</blockquote>
<h4 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h4><blockquote>
<ul>
<li>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁</li>
<li>让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实</li>
<li>设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量</li>
<li>既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后变回返回一个失败信息</li>
</ul>
</blockquote>
<h4 id="Java中活锁和死锁有什么区别？"><a href="#Java中活锁和死锁有什么区别？" class="headerlink" title="Java中活锁和死锁有什么区别？"></a>Java中活锁和死锁有什么区别？</h4><blockquote>
<p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
</blockquote>
<h4 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h4><blockquote>
<p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我看到一本书上写到。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
</blockquote>
<h4 id="你如何在Java中获取线程堆栈？"><a href="#你如何在Java中获取线程堆栈？" class="headerlink" title="你如何在Java中获取线程堆栈？"></a>你如何在Java中获取线程堆栈？</h4><blockquote>
<p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
</blockquote>
<h4 id="JVM中哪个参数是用来控制线程的栈堆栈小的？"><a href="#JVM中哪个参数是用来控制线程的栈堆栈小的？" class="headerlink" title="JVM中哪个参数是用来控制线程的栈堆栈小的？"></a>JVM中哪个参数是用来控制线程的栈堆栈小的？</h4><blockquote>
<p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。</p>
</blockquote>
<h4 id="Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="Java中synchronized 和 ReentrantLock 有什么不同？"></a>Java中synchronized 和 ReentrantLock 有什么不同？</h4><blockquote>
<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点，比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。ReentrantLock 类实现了 Lock接口，提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量扩展性。</p>
<p>ReentrantLock比synchronized的扩展性体现在几点上：</p>
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。<br>从性能上来说ReentrantLock比synchronized略有胜出（JDK6起），在JDK5中是远远胜出，为嘛不放弃synchronized呢？ReentrantLock的危险性要比同步机制高，如果忘记在finnally块中调用unlock，那么虽然代码表面上能正常运行，但实际上已经埋下了一颗定时炸弹，并很可能伤及其他代码。仅当内置锁不能满足需求时，才可以考虑使用ReentrantLock.</li>
</ul>
</blockquote>
<h4 id="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h4><blockquote>
<p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1.，这样T1就会先完成而T3最后完成。</p>
</blockquote>
<h4 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h4><blockquote>
<p>可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但放弃时间不确定，有可能刚刚放弃，马上又获得CPU时间片。这里需要注意的是yield()方法和sleep方法一样，线程并不会让出锁，和wait不同。</p>
</blockquote>
<h4 id="Java中Semaphore是什么？"><a href="#Java中Semaphore是什么？" class="headerlink" title="Java中Semaphore是什么？"></a>Java中Semaphore是什么？</h4><blockquote>
<p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
</blockquote>
<h4 id="Semaphore有什么作用？"><a href="#Semaphore有什么作用？" class="headerlink" title="Semaphore有什么作用？"></a>Semaphore有什么作用？</h4><blockquote>
<p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p>
</blockquote>
<h4 id="Swing是线程安全的吗？-为什么？"><a href="#Swing是线程安全的吗？-为什么？" class="headerlink" title="Swing是线程安全的吗？ 为什么？"></a>Swing是线程安全的吗？ 为什么？</h4><blockquote>
<p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。</p>
</blockquote>
<h4 id="Swing-API中那些方法是线程安全的？"><a href="#Swing-API中那些方法是线程安全的？" class="headerlink" title="Swing API中那些方法是线程安全的？"></a>Swing API中那些方法是线程安全的？</h4><blockquote>
<p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p>
</blockquote>
<h4 id="Java中invokeAndWait-和-invokeLater有什么区别？"><a href="#Java中invokeAndWait-和-invokeLater有什么区别？" class="headerlink" title="Java中invokeAndWait 和 invokeLater有什么区别？"></a>Java中invokeAndWait 和 invokeLater有什么区别？</h4><blockquote>
<p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。</p>
</blockquote>
<h4 id="如何在Java中创建Immutable对象？"><a href="#如何在Java中创建Immutable对象？" class="headerlink" title="如何在Java中创建Immutable对象？"></a>如何在Java中创建Immutable对象？</h4><blockquote>
<p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p>
</blockquote>
<h4 id="Java中的ReadWriteLock是什么？"><a href="#Java中的ReadWriteLock是什么？" class="headerlink" title="Java中的ReadWriteLock是什么？"></a>Java中的ReadWriteLock是什么？</h4><blockquote>
<p>ReadWriteLock是Java 5 中新增的一个接口，一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>
</blockquote>
<h4 id="单例模式的双检锁是什么？"><a href="#单例模式的双检锁是什么？" class="headerlink" title="单例模式的双检锁是什么？"></a>单例模式的双检锁是什么？</h4><blockquote>
<p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。可以参考我的这篇文章：</p>
<p><a href="http://dijia478.cn/blog/2015/04/18/2015-04-18-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%86%99%E5%87%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">如何正确的写出单例模式</a></p>
</blockquote>
<h4 id="如何在Java中创建线程安全的Singleton？"><a href="#如何在Java中创建线程安全的Singleton？" class="headerlink" title="如何在Java中创建线程安全的Singleton？"></a>如何在Java中创建线程安全的Singleton？</h4><blockquote>
<p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。</p>
</blockquote>
<h4 id="什么是多线程的上下文切换？"><a href="#什么是多线程的上下文切换？" class="headerlink" title="什么是多线程的上下文切换？"></a>什么是多线程的上下文切换？</h4><blockquote>
<p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
</blockquote>
<h4 id="写出3条你遵循的多线程最佳实践"><a href="#写出3条你遵循的多线程最佳实践" class="headerlink" title="写出3条你遵循的多线程最佳实践"></a>写出3条你遵循的多线程最佳实践</h4><blockquote>
<p>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p>
<ul>
<li><p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p>
</li>
<li><p>避免锁定和缩小同步的范围</p>
</li>
</ul>
<p>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p>
<ul>
<li>多用同步类少用wait 和 notify</li>
</ul>
<p>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p>
<ul>
<li>多用并发集合少用同步集合</li>
</ul>
<p>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</p>
</blockquote>
<h4 id="Java中的fork-join框架是什么？"><a href="#Java中的fork-join框架是什么？" class="headerlink" title="Java中的fork join框架是什么？"></a>Java中的fork join框架是什么？</h4><blockquote>
<p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。</p>
</blockquote>
<h4 id="Java中如何获取到线程dump文件？"><a href="#Java中如何获取到线程dump文件？" class="headerlink" title="Java中如何获取到线程dump文件？"></a>Java中如何获取到线程dump文件？</h4><blockquote>
<p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p>
<ul>
<li>获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</li>
<li>打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</li>
</ul>
<p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。</p>
</blockquote>
<h4 id="Linux环境下如何查找哪个线程使用CPU最长"><a href="#Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="Linux环境下如何查找哪个线程使用CPU最长?"></a>Linux环境下如何查找哪个线程使用CPU最长?</h4><blockquote>
<p>这是一个比较偏实践的问题，可以这么做：</p>
<ul>
<li>获取项目的pid，jps或者ps -ef | grep java</li>
<li>top -H -p pid，顺序不能改变</li>
</ul>
<p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号。<br>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。<br>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p>
</blockquote>
<h4 id="Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？"><a href="#Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？" class="headerlink" title="Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？"></a>Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</h4><blockquote>
<ul>
<li>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</li>
<li>CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。</li>
</ul>
</blockquote>
<h4 id="同步方法和同步块，哪个是更好的选择"><a href="#同步方法和同步块，哪个是更好的选择" class="headerlink" title="同步方法和同步块，哪个是更好的选择?"></a>同步方法和同步块，哪个是更好的选择?</h4><blockquote>
<p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。<br>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p>
</blockquote>
<h4 id="终止正在运行的线程的三种方法"><a href="#终止正在运行的线程的三种方法" class="headerlink" title="终止正在运行的线程的三种方法"></a>终止正在运行的线程的三种方法</h4><blockquote>
<ul>
<li>使用退出标志，是线程正常退出，也就是当run方法完成后线程终止；</li>
<li>使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样都是作废过期的方法，使用它们可能产生不可预料的结果；</li>
<li>使用interrupt方法中断线程；（推荐）</li>
</ul>
</blockquote>
<h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><blockquote>
<p>Java中线程的优先级分为1-10这10个等级，如果小于1或大于10则JDK抛出IllegalArgumentException()的异常，默认优先级是5。在Java中线程的优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。注意程序正确性不能依赖线程的优先级高低，因为操作系统可以完全不理会Java线程对于优先级的决定。</p>
</blockquote>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><blockquote>
<p>Java中有两种线程，一种是用户线程，另一种是守护线程。当进程中不存在非守护线程了，则守护线程自动销毁。通过setDaemon(true)设置线程为后台线程。注意thread.setDaemon(true)必须在thread.start()之前设置，否则会报IllegalThreadStateException异常；在Daemon线程中产生的新线程也是Daemon的；在使用ExecutorSerice等多线程框架时，会把守护线程转换为用户线程，并且也会把优先级设置为Thread.NORM_PRIORITY。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
</blockquote>
<h4 id="synchronized的类锁与对象锁"><a href="#synchronized的类锁与对象锁" class="headerlink" title="synchronized的类锁与对象锁"></a>synchronized的类锁与对象锁</h4><blockquote>
<ul>
<li><p>类锁：在方法上加上static synchronized的锁，或者synchronized(xxx.class)的锁。如下代码中的method1和method2：</p>
</li>
<li><p>对象锁：参考method4, method5,method6.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockStrategy</span> </span>&#123;</span><br><span class="line">&gt;     </span><br><span class="line">&gt;    <span class="keyword">public</span> Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">synchronized</span>(LockStrategy.class)&#123;&#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;&#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">synchronized</span>(object1)&#123;&#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>注意方法method4和method5中的同步块也是互斥的。</p>
</blockquote>
<h4 id="同步不具备继承性"><a href="#同步不具备继承性" class="headerlink" title="同步不具备继承性"></a>同步不具备继承性</h4><blockquote>
<p>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。同步不具有继承性（声明为synchronized的父类方法A，在子类中重写之后并不具备synchronized的特性）。</p>
</blockquote>
<h4 id="不同线程间的通信问题"><a href="#不同线程间的通信问题" class="headerlink" title="不同线程间的通信问题"></a>不同线程间的通信问题</h4><blockquote>
<p>在Java中提供了各种各样的输入/输出流Stream，使我们能够很方便地对数据进行操作，其中管道流（pipeStream)是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道中读数据，通过使用管道，实现不同线程间的通信，而无须借助类似临时文件之类的东西。在JDK中使用4个类来使线程间可以进行通信：PipedInputStream, PipedOutputStream, PipedReader, PipedWriter。使用代码类似inputStream.connect(outputStream)或outputStream.connect(inputStream)使两个Stream之间产生通信连接。</p>
<p><strong>几种进程间的通信方式</strong></p>
<ul>
<li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
</blockquote>
<h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><blockquote>
<p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。join与synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键字使用的是“对象监视器”做为同步。<br>join提供了另外两种实现方法：join(long millis)和join(long millis, int nanos)，至多等待多长时间而退出等待(释放锁)，退出等待之后还可以继续运行。内部是通过wait方法来实现的。</p>
</blockquote>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><blockquote>
<p>ThreadLocal可以实现每个线程绑定自己的值，即每个线程有各自独立的副本而互相不受影响。一共有四个方法：get, set, remove, initialValue。可以重写initialValue()方法来为ThreadLocal赋初值。<br>ThreadLocal建议设置为static类型的。<br>使用类InheritableThreadLocal可以在子线程中取得父线程继承下来的值。可以采用重写childValue（Object parentValue）方法来更改继承的值。<br>注意：在线程池的情况下，在ThreadLocal业务周期处理完成时，最好显式的调用remove()方法，清空”线程局部变量”中的值。正常情况下使用ThreadLocal不会造成内存溢出，弱引用的只是threadLocal，保存的值依然是强引用的，如果threadLocal依然被其他对象强引用，”线程局部变量”是无法回收的。</p>
</blockquote>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><blockquote>
<p>ReentrantLock提供了tryLock方法，tryLock调用的时候，如果锁被其他线程持有，那么tryLock会立即返回，返回结果为false；如果锁没有被其他线程持有，那么当前调用线程会持有锁，并且tryLock返回的结果为true。<br>可以在构造ReentranLock时使用公平锁，公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。synchronized中的锁时非公平的，默认情况下ReentrantLock也是非公平的，但是可以在构造函数中指定使用公平锁。<br>对于ReentrantLock来说，还有一个十分实用的特性，它可以同时绑定多个Condition条件，以实现更精细化的同步控制。<br>ReentrantLock使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">&gt; lock.lock();</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&gt;     lock.unlock();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="ReentrantLock中的其余方法"><a href="#ReentrantLock中的其余方法" class="headerlink" title="ReentrantLock中的其余方法"></a>ReentrantLock中的其余方法</h4><blockquote>
<ul>
<li>int getHoldCount()：查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。</li>
<li>int getQueueLength()：返回正等待获取此锁定的线程估计数。比如有5个线程，1个线程首先执行await()方法，那么在调用getQueueLength方法后返回值是4，说明有4个线程在等待lock的释放。</li>
<li>int getWaitQueueLength(Condition condition)：返回等待此锁定相关的给定条件Condition的线程估计数。比如有5个线程，每个线程都执行了同一个condition对象的await方法，则调用getWaitQueueLength(Condition condition)方法时返回的int值是5。</li>
<li>boolean hasQueuedThread(Thread thread)：查询指定线程是否正在等待获取此锁定。</li>
<li>boolean hasQueuedThreads()：查询是否有线程正在等待获取此锁定。</li>
<li>boolean hasWaiters(Condition condition)：查询是否有线程正在等待与此锁定有关的condition条件。</li>
<li>boolean isFair()：判断是不是公平锁。</li>
<li>boolean isHeldByCurrentThread()：查询当前线程是否保持此锁定。</li>
<li>boolean isLocked()：查询此锁定是否由任意线程保持。</li>
<li>void lockInterruptibly()：如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常。</li>
</ul>
</blockquote>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><blockquote>
<p>一个Condition和一个Lock关联在一起，就想一个条件队列和一个内置锁相关联一样。要创建一个Condition，可以在相关联的Lock上调用Lock.newCondition方法。正如Lock比内置加锁提供了更为丰富的功能，Condition同样比内置条件队列提供了更丰富的功能：在每个锁上可存在多个等待、条件等待可以是可中断的或者不可中断的、基于时限的等待，以及公平的或非公平的队列操作。与内置条件队列不同的是，对于每个Lock，可以有任意数量的Condition对象。Condition对象继承了相关的Lock对象的公平性，对于公平的锁，线程会依照FIFO顺序从Condition.await中释放。<br>注意：在Condition对象中，与wait,notify和notifyAll方法对于的分别是await,signal,signalAll。但是，Condition对Object进行了扩展，因而它也包含wait和notify方法。一定要确保使用的版本——await和signal.</p>
</blockquote>
<h4 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h4><blockquote>
<p>读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排它锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有Thread进行写操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁后才能进行写入操作。即读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。(lock.readlock.lock(), lock.readlock.unlock, lock.writelock.lock, lock.writelock.unlock)。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排它锁有了很大的提升。Java中使用ReentrantReadWriteLock实现读写锁。</p>
</blockquote>
<h4 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h4><blockquote>
<p>建议不要采用DCL的写法，建议使用下面这种静态内部类写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">&gt;     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>或者这种枚举式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</span><br><span class="line">&gt;     INSTANCE;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="线程组ThreadGroup"><a href="#线程组ThreadGroup" class="headerlink" title="线程组ThreadGroup"></a>线程组ThreadGroup</h4><blockquote>
<p>为了有效地对一些线程进行组织管理，通常的情况下事创建一个线程组，然后再将部分线程归属到该组中，这样可以对零散的线程对象进行有效的组织和规划。</p>
</blockquote>
<h4 id="ReentrantLock与synchonized区别"><a href="#ReentrantLock与synchonized区别" class="headerlink" title="ReentrantLock与synchonized区别"></a>ReentrantLock与synchonized区别</h4><blockquote>
<ul>
<li>ReentrantLock可以中断地获取锁（void lockInterruptibly() throws InterruptedException）</li>
<li>ReentrantLock可以尝试非阻塞地获取锁（boolean tryLock()）</li>
<li>ReentrantLock可以超时获取锁。通过tryLock(timeout, unit)，可以尝试获得锁，并且指定等待的时间。</li>
<li>ReentrantLock可以实现公平锁。通过new ReentrantLock(true)实现。</li>
<li>ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的的wait(), notify(), notifyAll()方法可以实现一个隐含条件，如果要和多于一个的条件关联的对象，就不得不额外地添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法即可。</li>
</ul>
</blockquote>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><blockquote>
<p>锁降级是指写锁降级成读锁。如果当前线程拥有写锁，然后将其释放，最后获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，最后释放（先前拥有的）写锁的过程。<br>锁降级中的读锁是否有必要呢？答案是必要。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p>
</blockquote>
<h4 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h4><blockquote>
<ul>
<li>ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列。 </li>
<li>LinkedeBlockingQueue:一个有链表结构组成的有界阻塞队列。 </li>
<li>PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列 </li>
<li>DelayQueue:一个使用优先级队列实现的无界阻塞队列。 </li>
<li>SynchronousQueue:一个不存储元素的阻塞队列。 </li>
<li>LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。 </li>
<li>LinkedBlockingDeque:一个由链表结构组成的双向阻塞队列。</li>
</ul>
</blockquote>
<h4 id="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"><a href="#高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"></a>高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h4><blockquote>
<p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p>
<ul>
<li>高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</li>
<li>并发不高、任务执行时间长的业务要区分开看：</li>
<li>假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</li>
<li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li>
<li>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考第二条。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li>
</ul>
</blockquote>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="dijia478 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="dijia478 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/多线程/" rel="tag"><i class="fa fa-tag"></i> 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2015/12/03/2015-12-03-九种内部排序算法的Java实现及其性能测试/" rel="next" title="九种内部排序算法的Java实现及其性能测试">
                <i class="fa fa-chevron-left"></i> 九种内部排序算法的Java实现及其性能测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2016/03/27/2016-03-27-JVM内存泄漏及性能调优/" rel="prev" title="JVM内存泄漏及性能调优">
                JVM内存泄漏及性能调优 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="dijia478" />
            
              <p class="site-author-name" itemprop="name">dijia478</p>
              <p class="site-description motion-element" itemprop="description">写写代码，发发感悟，聊聊人生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://segmentfault.com/" title="SegmentFault" target="_blank">SegmentFault</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://stackoverflow.com/" title="Stack Overflow" target="_blank">Stack Overflow</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.csdn.net/" title="CSDN" target="_blank">CSDN</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是线程？"><span class="nav-number">1.</span> <span class="nav-text">什么是线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程有什么用？"><span class="nav-number">2.</span> <span class="nav-text">多线程有什么用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程和进程有什么区别？"><span class="nav-number">3.</span> <span class="nav-text">线程和进程有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何在Java中实现多线程？"><span class="nav-number">4.</span> <span class="nav-text">如何在Java中实现多线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用Runnable还是Thread？"><span class="nav-number">5.</span> <span class="nav-text">用Runnable还是Thread？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-类中的start和-run方法有什么区别？"><span class="nav-number">6.</span> <span class="nav-text">Thread 类中的start和 run方法有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中Runnable和Callable有什么不同？"><span class="nav-number">7.</span> <span class="nav-text">Java中Runnable和Callable有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中CyclicBarrier-和-CountDownLatch有什么不同？"><span class="nav-number">8.</span> <span class="nav-text">Java中CyclicBarrier 和 CountDownLatch有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中如何停止一个线程？"><span class="nav-number">9.</span> <span class="nav-text">Java中如何停止一个线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个线程运行时发生异常会怎样？"><span class="nav-number">10.</span> <span class="nav-text">一个线程运行时发生异常会怎样？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何在两个线程间共享数据？"><span class="nav-number">11.</span> <span class="nav-text">如何在两个线程间共享数据？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是线程安全？Vector是一个线程安全类吗？"><span class="nav-number">12.</span> <span class="nav-text">什么是线程安全？Vector是一个线程安全类吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何强制启动一个线程？"><span class="nav-number">13.</span> <span class="nav-text">如何强制启动一个线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java多线程中调用wait和-sleep方法有什么不同？"><span class="nav-number">14.</span> <span class="nav-text">Java多线程中调用wait和 sleep方法有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-sleep-0-的作用是什么？"><span class="nav-number">15.</span> <span class="nav-text">Thread.sleep(0)的作用是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么唤醒一个阻塞的线程？"><span class="nav-number">16.</span> <span class="nav-text">怎么唤醒一个阻塞的线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是阻塞式方法？"><span class="nav-number">17.</span> <span class="nav-text">什么是阻塞式方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是线程池？-为什么要使用它？"><span class="nav-number">18.</span> <span class="nav-text">什么是线程池？ 为什么要使用它？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果你提交任务时，线程池队列已满，这时会发生什么？"><span class="nav-number">19.</span> <span class="nav-text">如果你提交任务时，线程池队列已满，这时会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程池中submit和-execute方法有什么区别？"><span class="nav-number">20.</span> <span class="nav-text">Java线程池中submit和 execute方法有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中用到的线程调度算法是什么？"><span class="nav-number">21.</span> <span class="nav-text">Java中用到的线程调度算法是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java内存模型是什么？"><span class="nav-number">22.</span> <span class="nav-text">Java内存模型是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中的volatile-变量是什么？"><span class="nav-number">23.</span> <span class="nav-text">Java中的volatile 变量是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-变量和-atomic-变量有什么不同？"><span class="nav-number">24.</span> <span class="nav-text">volatile 变量和 atomic 变量有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程类的构造方法、静态块是被哪个线程调用的"><span class="nav-number">25.</span> <span class="nav-text">线程类的构造方法、静态块是被哪个线程调用的?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果同步块内的线程抛出异常会发生什么？"><span class="nav-number">26.</span> <span class="nav-text">如果同步块内的线程抛出异常会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是乐观锁和悲观锁？"><span class="nav-number">27.</span> <span class="nav-text">什么是乐观锁和悲观锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是自旋？"><span class="nav-number">28.</span> <span class="nav-text">什么是自旋？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是CAS？"><span class="nav-number">29.</span> <span class="nav-text">什么是CAS？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是AQS？"><span class="nav-number">30.</span> <span class="nav-text">什么是AQS？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是ThreadLocal变量？"><span class="nav-number">31.</span> <span class="nav-text">什么是ThreadLocal变量？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是FutureTask？"><span class="nav-number">32.</span> <span class="nav-text">什么是FutureTask？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不可变对象对多线程有什么帮助？"><span class="nav-number">33.</span> <span class="nav-text">不可变对象对多线程有什么帮助？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中什么是竞态条件？-举个例子说明。"><span class="nav-number">34.</span> <span class="nav-text">Java中什么是竞态条件？ 举个例子说明。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中notify-和-notifyAll有什么区别？"><span class="nav-number">35.</span> <span class="nav-text">Java中notify 和 notifyAll有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><span class="nav-number">36.</span> <span class="nav-text">为什么wait, notify 和 notifyAll这些方法不在thread类里面？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-notify-notifyAll用法？"><span class="nav-number">37.</span> <span class="nav-text">wait, notify, notifyAll用法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait方法和notify-notifyAll方法在放弃对象监视器时有什么区别？"><span class="nav-number">38.</span> <span class="nav-text">wait方法和notify/notifyAll方法在放弃对象监视器时有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程中的忙循环是什么"><span class="nav-number">39.</span> <span class="nav-text">多线程中的忙循环是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么检测一个线程是否持有对象监视器？"><span class="nav-number">40.</span> <span class="nav-text">怎么检测一个线程是否持有对象监视器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中interrupted-和-isInterruptedd方法的区别？"><span class="nav-number">41.</span> <span class="nav-text">Java中interrupted 和 isInterruptedd方法的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么你应该在循环中检查等待条件"><span class="nav-number">42.</span> <span class="nav-text">为什么你应该在循环中检查等待条件?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中的同步集合与并发集合有什么区别？"><span class="nav-number">43.</span> <span class="nav-text">Java中的同步集合与并发集合有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中ConcurrentHashMap的并发度是什么？"><span class="nav-number">44.</span> <span class="nav-text">Java中ConcurrentHashMap的并发度是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中堆和栈有什么不同？"><span class="nav-number">45.</span> <span class="nav-text">Java中堆和栈有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者消费者模型的作用是什么？"><span class="nav-number">46.</span> <span class="nav-text">生产者消费者模型的作用是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何写代码来解决生产者消费者问题？"><span class="nav-number">47.</span> <span class="nav-text">如何写代码来解决生产者消费者问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是死锁？"><span class="nav-number">48.</span> <span class="nav-text">什么是死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何避免死锁？"><span class="nav-number">49.</span> <span class="nav-text">如何避免死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中活锁和死锁有什么区别？"><span class="nav-number">50.</span> <span class="nav-text">Java中活锁和死锁有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么检测一个线程是否拥有锁？"><span class="nav-number">51.</span> <span class="nav-text">怎么检测一个线程是否拥有锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你如何在Java中获取线程堆栈？"><span class="nav-number">52.</span> <span class="nav-text">你如何在Java中获取线程堆栈？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM中哪个参数是用来控制线程的栈堆栈小的？"><span class="nav-number">53.</span> <span class="nav-text">JVM中哪个参数是用来控制线程的栈堆栈小的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中synchronized-和-ReentrantLock-有什么不同？"><span class="nav-number">54.</span> <span class="nav-text">Java中synchronized 和 ReentrantLock 有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><span class="nav-number">55.</span> <span class="nav-text">有三个线程T1，T2，T3，怎么确保它们按顺序执行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread类中的yield方法有什么作用？"><span class="nav-number">56.</span> <span class="nav-text">Thread类中的yield方法有什么作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中Semaphore是什么？"><span class="nav-number">57.</span> <span class="nav-text">Java中Semaphore是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore有什么作用？"><span class="nav-number">58.</span> <span class="nav-text">Semaphore有什么作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Swing是线程安全的吗？-为什么？"><span class="nav-number">59.</span> <span class="nav-text">Swing是线程安全的吗？ 为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Swing-API中那些方法是线程安全的？"><span class="nav-number">60.</span> <span class="nav-text">Swing API中那些方法是线程安全的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中invokeAndWait-和-invokeLater有什么区别？"><span class="nav-number">61.</span> <span class="nav-text">Java中invokeAndWait 和 invokeLater有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何在Java中创建Immutable对象？"><span class="nav-number">62.</span> <span class="nav-text">如何在Java中创建Immutable对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中的ReadWriteLock是什么？"><span class="nav-number">63.</span> <span class="nav-text">Java中的ReadWriteLock是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式的双检锁是什么？"><span class="nav-number">64.</span> <span class="nav-text">单例模式的双检锁是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何在Java中创建线程安全的Singleton？"><span class="nav-number">65.</span> <span class="nav-text">如何在Java中创建线程安全的Singleton？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是多线程的上下文切换？"><span class="nav-number">66.</span> <span class="nav-text">什么是多线程的上下文切换？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写出3条你遵循的多线程最佳实践"><span class="nav-number">67.</span> <span class="nav-text">写出3条你遵循的多线程最佳实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中的fork-join框架是什么？"><span class="nav-number">68.</span> <span class="nav-text">Java中的fork join框架是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中如何获取到线程dump文件？"><span class="nav-number">69.</span> <span class="nav-text">Java中如何获取到线程dump文件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux环境下如何查找哪个线程使用CPU最长"><span class="nav-number">70.</span> <span class="nav-text">Linux环境下如何查找哪个线程使用CPU最长?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？"><span class="nav-number">71.</span> <span class="nav-text">Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步方法和同步块，哪个是更好的选择"><span class="nav-number">72.</span> <span class="nav-text">同步方法和同步块，哪个是更好的选择?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终止正在运行的线程的三种方法"><span class="nav-number">73.</span> <span class="nav-text">终止正在运行的线程的三种方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的优先级"><span class="nav-number">74.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#守护线程"><span class="nav-number">75.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized的类锁与对象锁"><span class="nav-number">76.</span> <span class="nav-text">synchronized的类锁与对象锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步不具备继承性"><span class="nav-number">77.</span> <span class="nav-text">同步不具备继承性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同线程间的通信问题"><span class="nav-number">78.</span> <span class="nav-text">不同线程间的通信问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join方法"><span class="nav-number">79.</span> <span class="nav-text">join方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">80.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">81.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock中的其余方法"><span class="nav-number">82.</span> <span class="nav-text">ReentrantLock中的其余方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition"><span class="nav-number">83.</span> <span class="nav-text">Condition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写锁ReentrantReadWriteLock"><span class="nav-number">84.</span> <span class="nav-text">读写锁ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全的单例模式"><span class="nav-number">85.</span> <span class="nav-text">线程安全的单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程组ThreadGroup"><span class="nav-number">86.</span> <span class="nav-text">线程组ThreadGroup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock与synchonized区别"><span class="nav-number">87.</span> <span class="nav-text">ReentrantLock与synchonized区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁降级"><span class="nav-number">88.</span> <span class="nav-text">锁降级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java里的阻塞队列"><span class="nav-number">89.</span> <span class="nav-text">Java里的阻塞队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"><span class="nav-number">90.</span> <span class="nav-text">高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dijia478</span>

  
</div>









<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_pv">
    本月总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
</div>
|
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">全站共144.1k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
