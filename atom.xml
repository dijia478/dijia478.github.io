<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dijia478-刘力源</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dijia478.cn/"/>
  <updated>2018-01-02T04:15:38.496Z</updated>
  <id>http://dijia478.cn/</id>
  
  <author>
    <name>dijia478</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tomcat在Linux服务器上的BIO、NIO、APR模式设置</title>
    <link href="http://dijia478.cn//blog/2017/12/26/2017-12-26-Tomcat%E5%9C%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84BIO%E3%80%81NIO%E3%80%81APR%E6%A8%A1%E5%BC%8F%E8%AE%BE%E7%BD%AE/"/>
    <id>http://dijia478.cn//blog/2017/12/26/2017-12-26-Tomcat在Linux服务器上的BIO、NIO、APR模式设置/</id>
    <published>2017-12-26T03:21:57.000Z</published>
    <updated>2018-01-02T04:15:38.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、BIO、NIO、AIO"><a href="#一、BIO、NIO、AIO" class="headerlink" title="一、BIO、NIO、AIO"></a>一、BIO、NIO、AIO</h2><h3 id="先了解四个概念"><a href="#先了解四个概念" class="headerlink" title="先了解四个概念"></a>先了解四个概念</h3><p><strong>同步：</strong> 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。</p><p><strong>异步：</strong>  委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。<br><a id="more"></a><br><strong>阻塞：</strong>  ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。</p><p><strong>非阻塞：</strong>柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。</p><h3 id="Java对BIO、NIO、AIO的支持"><a href="#Java对BIO、NIO、AIO的支持" class="headerlink" title="Java对BIO、NIO、AIO的支持"></a>Java对BIO、NIO、AIO的支持</h3><p><strong>Java BIO：</strong> 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><p><strong>Java NIO：</strong> 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><p><strong>Java AIO(NIO.2)：</strong> 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</p><h3 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析"></a>BIO、NIO、AIO适用场景分析</h3><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><h2 id="二、tomcat三种模式简介"><a href="#二、tomcat三种模式简介" class="headerlink" title="二、tomcat三种模式简介"></a>二、tomcat三种模式简介</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO(blocking I/O)，顾名思义，即阻塞式I/O操作，表示Tomcat使用的是传统的Java I/O操作(即java.io包及其子包)。Tomcat在默认情况下，就是以bio模式运行的。遗憾的是，就一般而言，bio模式是三种运行模式中性能最低的一种。我们可以通过Tomcat Manager来查看服务器的当前状态。</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，因此nio也被看成是non-blocking I/O的缩写。它拥有比传统I/O操作(bio)更好的并发运行性能。</p><h3 id="APR"><a href="#APR" class="headerlink" title="APR"></a>APR</h3><p>(Apache Portable Runtime/Apache可移植运行库)，是Apache HTTP服务器的支持库。你可以简单地理解为，Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高Tomcat对静态文件的处理性能。 Tomcat apr也是在Tomcat上运行高并发应用的首选模式。</p><h2 id="三、tomcat三种模式性能比较"><a href="#三、tomcat三种模式性能比较" class="headerlink" title="三、tomcat三种模式性能比较"></a>三、tomcat三种模式性能比较</h2><p>这里我引用了网友给出的测试结果</p><img src="/blog/2017/12/26/2017-12-26-Tomcat在Linux服务器上的BIO、NIO、APR模式设置/tomcat01.png"><h2 id="四、tomcat模式设置"><a href="#四、tomcat模式设置" class="headerlink" title="四、tomcat模式设置"></a>四、tomcat模式设置</h2><p>我这里演示的是tomcat7，默认是BIO模式的。而tomcat8是默认NIO模式的。</p><img src="/blog/2017/12/26/2017-12-26-Tomcat在Linux服务器上的BIO、NIO、APR模式设置/tomcat02.png"><h3 id="BIO模式"><a href="#BIO模式" class="headerlink" title="BIO模式"></a>BIO模式</h3><p>tomcat7默认就是。如果你是tomcat8或9想设置成BIO模式的，那么在tomcat目录里的conf目录里的server.xml文件中修改。找到设置端口号8080的那个标签，主要是修改protocol属性为<code>HTTP/1.1</code>，重启tomcat就会使用BIO模式。tomcat7默认就是这个样子的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="NIO模式"><a href="#NIO模式" class="headerlink" title="NIO模式"></a>NIO模式</h3><p>在和设置BIO模式同样的位置上，修改protocol属性为<code>org.apache.coyote.http11.Http11NioProtocol</code>，重启tomcat就会使用NIO模式。tomcat8以上默认就是这个样子的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="APR模式"><a href="#APR模式" class="headerlink" title="APR模式"></a>APR模式</h3><p>启用这种模式稍微麻烦一些，除了需要改配置文件，还需要安装一些依赖库，以下就是安装所需的条件：</p><pre><code>1. 最新的apr2. 最新的apr-util3. tomcat-native.tar.gz(在tomcat/bin/下有相应的安装tar包)</code></pre><p>前两个依赖库的官方下载地址：<a href="http://apr.apache.org/download.cgi" target="_blank" rel="noopener">http://apr.apache.org/download.cgi</a></p><p>先改配置文件，和改BIO,NIO模式的位置一样，修改protocol属性为<code>org.apache.coyote.http11.Http11AprProtocol</code>，注意和NIO的很像，但不一样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>现在先安装apr，在解压好的apr目录下，执行下面的命令，指定apr安装目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/apr &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>再安装apr-util，在解压好的apr-util目录下，执行下面的命令，指定apr目录和apr-util安装目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="keyword">with</span>-apr=/usr/local/apr/ --prefix=/usr/local/apr-util &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>再安装tomcat-native，这个不用下载，在tomcat/bin/下有相应的安装tar包，在解压好的tomcat-native目录下，执行下面的命令，指定指定apr目录和JAVA_HOME目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./native/configure --<span class="keyword">with</span>-apr=/usr/local/apr --<span class="keyword">with</span>-java-home=/usr/share/jdk1<span class="number">.8</span> &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完后记得在 /etc/profile 文件中的JAVA_HOME环境变量后面多加一条APR的环境变量（注意你自己安装的apr目录）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/lib</span><br></pre></td></tr></table></figure><p>用source /etc/profile命令让环境变量配置立即生效，启动tomcat，就是APR模式了</p><h2 id="五、如何确定自己当前的模式"><a href="#五、如何确定自己当前的模式" class="headerlink" title="五、如何确定自己当前的模式"></a>五、如何确定自己当前的模式</h2><p>启动tomcat后，可以在tomcat/logs目录下，执行如下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f catalina.out</span><br></pre></td></tr></table></figure><p>我这里就是成功启动APR模式后显示的样子</p><p><img src="tomcat03.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、BIO、NIO、AIO&quot;&gt;&lt;a href=&quot;#一、BIO、NIO、AIO&quot; class=&quot;headerlink&quot; title=&quot;一、BIO、NIO、AIO&quot;&gt;&lt;/a&gt;一、BIO、NIO、AIO&lt;/h2&gt;&lt;h3 id=&quot;先了解四个概念&quot;&gt;&lt;a href=&quot;#先了解四个概念&quot; class=&quot;headerlink&quot; title=&quot;先了解四个概念&quot;&gt;&lt;/a&gt;先了解四个概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;同步：&lt;/strong&gt; 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步：&lt;/strong&gt;  委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://dijia478.cn/categories/Linux/"/>
    
    
      <category term="Tomcat" scheme="http://dijia478.cn/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴Java开发手册-编程规约</title>
    <link href="http://dijia478.cn//blog/2017/11/02/2017-11-02-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    <id>http://dijia478.cn//blog/2017/11/02/2017-11-02-阿里巴巴Java开发手册/</id>
    <published>2017-11-02T11:24:46.000Z</published>
    <updated>2018-01-02T05:42:20.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>《阿里巴巴Java开发手册》是阿里巴巴集团技术团队的集体智慧结晶和经验总<br>结，经历了多次大规模一线实战的检验及不断的完善，系统化地整理成册，回馈给广<br>大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是<br>编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表<br>结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续<br>维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以Java开发者为中心<br>视角，划分为编程规约、异常日志、单元测试、安全规约、工程结构、MySQL数据库六<br>个维度，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，<br>规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内<br>容做了适当扩展和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要<br>提防的雷区，以及真实的错误案例。<br>本手册的愿景是码出高效，码出质量。现代软件架构都需要协同开发完成，高效<br>协作即降低协同成本，提升沟通效率，所谓无规矩不成方圆，无规范不能协作。众所<br>周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如<br>果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是<br>消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式<br>一起做事，提升协作效率。代码的字里行间流淌的是软件生命中的血液，质量的提升<br>是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。</p></blockquote><a id="more"></a><h2 id="一-、编程规约"><a href="#一-、编程规约" class="headerlink" title="一 、编程规约"></a>一 、编程规约</h2><h3 id="一-命名风格"><a href="#一-命名风格" class="headerlink" title="( 一 ) 命名风格"></a>( 一 ) 命名风格</h3><ol><li><p>【强制】代码中的命名均不能以<code>下划线或美元符号</code>开始，也不能以<code>下划线或美元符号</code>结束。<br>反例：<code>_name / __name / $name / name_ / name$ / name__</code></p></li><li><p>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式<br>也要避免采用。<br>正例： alibaba /  taobao /  youku /  hangzhou 等国际通用的名称，可视同英文。<br>反例：DaZhePromotion [打折] /  getPingfenByName() [评分] /  int 某变量 = 3</p></li><li><p>【强制】类名使用 UpperCamelCase 风格，但以下情形例外： DO /  BO  /  DTO /  VO /  AO /<br>PO 等。<br>正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</p></li><li><p>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从<br>驼峰形式。<br>正例： localValue / getHttpMessage() / inputUserId</p></li><li><p>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例：MAX_STOCK_COUNT<br>反例：MAX_COUNT</p></li><li><p>【强制】抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类<br>命名以它要测试的类名开始，以 Test 结尾。</p></li><li><p>【强制】类型与中括号紧挨相连来定义数组。<br>正例：定义整形数组 <code>int[] arrayDemo;</code><br>反例：在 main 参数中，使用 String args[]来定义。</p></li><li><p>【强制】 POJO 类中布尔类型的变量，都不要加 is 前缀 ，否则部分框架解析会引起序列化错误。<br>反例：定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是isDeleted() ， RPC框架在反向解析的时候，“误以为”对应的属性名称是 deleted ，导致属性 获取不到，进而抛出异常。</p></li><li><p>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用<br><code>单数</code>形式，但是类名如果有复数含义，类名可以使用复数形式。<br>正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils（ 此规则参考 spring 的框架结构 ）</p></li><li><p>【强制】杜绝完全不规范的缩写，避免望文不知义。<br>反例： AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成  condi ，此类随<br>意缩写严重降低了代码的可阅读性。</p></li><li><p>【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词<br>组合来表达其意。<br>正例：从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。<br>反例：变量int a; 的随意命名方式。</p></li><li><p>【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。<br>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br>正例：<br><code>public class OrderFactory;</code><br><code>public class LoginProxy;</code><br><code>public class ResourceObserver;</code></p></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号 （public 也不要加 ） ，保持代码的简洁<br>性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是<br>与接口方法相关，并且是整个应用的基础常量。<br>正例：接口方法签名<code>void f();</code><br>接口基础常量 <code>String COMPANY = &quot;alibaba&quot;;</code><br>反例：接口方法定义 <code>public abstract void f();</code><br>说明： JDK 8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默<br>认实现。</p></li><li><p>接口和实现类的命名有两套规则：<br>1 ）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部<br>的实现类用 Impl 的后缀与接口区别。<br>正例： CacheServiceImpl 实现 CacheService 接口。<br>2 ）【推荐】如果是形容能力的接口名称，取对应的形容词为接口名 （ 通常是 –able 的形式 ）。<br>正例： AbstractTranslator 实现  Translatable 。</p></li><li><p>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS /  UNKNOWN_REASON 。</p></li><li><p>【参考】各层命名规约：<br>A) Service / DAO 层方法命名规约<br> 1 ） 获取单个对象的方法用 <code>get</code> 作前缀。<br> 2 ） 获取多个对象的方法用 <code>list</code> 作前缀。<br> 3 ） 获取统计值的方法用 <code>count</code> 作前缀。<br> 4 ） 插入的方法用 <code>save/insert</code> 作前缀。<br> 5 ） 删除的方法用 <code>remove/delete</code> 作前缀。<br> 6 ） 修改的方法用 <code>update</code> 作前缀。<br>B) 领域模型命名规约<br> 1 ） 数据对象：<code>xxxDO</code> ， xxx 即为数据表名。<br> 2 ） 数据传输对象： <code>xxxDTO</code> ， xxx 为业务领域相关的名称。<br> 3 ） 展示对象： <code>xxxVO</code> ， xxx 一般为网页名称。<br> 4 ） POJO 是 DO / DTO / BO / VO 的统称，禁止命名成 xxxPOJO 。</p></li></ol><h3 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="( 二 )  常量定义"></a>( 二 )  常量定义</h3><ol><li><p>【强制】不允许任何魔法值 （ 即未经预先定义的常量 ） 直接出现在代码中。<br>反例：<br><code>String key = &quot;Id#taobao_&quot; + tradeId;</code><br><code>cache.put(key, value);</code></p></li><li><p>【强制】 long 或者 Long 初始赋值时，使用大写的 L ，不能是小写的 l ，小写容易跟数字 1 混<br>淆，造成误解。<br>说明：<code>Long a = 2l;</code> 写的是数字的 21，还是 Long 型的 2?</p></li><li><p>【推荐】不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。<br>说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。<br>正例：缓存相关常量放在类 CacheConsts 下 ； 系统配置相关常量放在类 ConfigConsts 下。</p></li><li><p>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<br>1 ） 跨应用共享常量：放置在二方库中，通常是 client . jar 中的 constant 目录下。<br>2 ） 应用内共享常量：放置在一方库中，通常是 子模块 中的 constant 目录下。<br>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类 A 中： <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES = <span class="string">"yes"</span>;</span><br><span class="line">类 B 中： <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES = <span class="string">"y"</span>;</span><br><span class="line">A.YES.equals(B.YES)，预期是 <span class="keyword">true</span> ，但实际返回为 <span class="keyword">false</span> ，导致线上问题。</span><br></pre></td></tr></table></figure><p>3 ） 子工程内部共享常量：即在当前子工程的 constant 目录下。<br>4 ） 包内共享常量：即在当前包下单独的 constant 目录下。<br>5 ） 类内共享常量：直接在类内部 private static final 定义。</p></li><li><p>【推荐】如果变量值仅在一个固定范围内变化用 enum 类型来定义。<br>说明：如果存在名称之外的延伸属性使用 enum 类型，下面正例中的数字就是延伸信息，表示<br>一年中的第几个季节。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum &#123;</span><br><span class="line">    SPRING(<span class="number">1</span>), SUMMER(<span class="number">2</span>), AUTUMN(<span class="number">3</span>), WINTER(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> seq;</span><br><span class="line">    SeasonEnum(<span class="keyword">int</span> seq)&#123;</span><br><span class="line">        <span class="keyword">this</span>.seq = seq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="三-代码格式"><a href="#三-代码格式" class="headerlink" title="( 三 ) 代码格式"></a>( 三 ) 代码格式</h3><ol><li>【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行 ； 如果<br>是非空代码块则：<br>1 ） 左大括号前不换行。<br>2 ） 左大括号后换行。<br>3 ） 右大括号前换行。<br>4 ） 右大括号后还有 else 等代码则不换行 ； 表示终止的右大括号后必须换行。</li><li>【强制】 左小括号和字符之间不出现空格 ； 同样，右小括号和字符之间也不出现空格。详见<br>第 5 条下方正例提示。<br>反例： if (<code>空格</code>a == b<code>空格</code>)</li><li>【强制】 if / for / while / switch / do 等保留字与括号之间都必须加空格。</li><li>【强制】任何二目、三目运算符的左右两边都需要加一个空格。<br>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</li><li><p>【强制】采用 4 个空格缩进，禁止使用 tab 字符。<br>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，<br>请勿勾选 <code>Use tab character</code> ；而在 eclipse 中，必须勾选 <code>insert spaces for tabs</code> 。<br>正例：  （ 涉及 1-5 点 ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缩进 4 个空格</span></span><br><span class="line">    <span class="number">5</span> / <span class="number">36</span> String say = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="comment">// 运算符的左右必须有一个空格</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(say);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左大括号前加空格且不换行；左大括号后换行</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"world"</span>);</span><br><span class="line">        <span class="comment">// 右大括号前换行，右大括号后有 else，不用换行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">        <span class="comment">// 在右大括号后直接结束，则必须换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【强制】注释的双斜线与注释内容之间有且仅有一个空格。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是示例注释，请注意在双斜线之后有一个空格</span></span><br><span class="line">String ygb = <span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure></li><li><p>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：<br>1 ） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>2 ） 运算符与下文一起换行。<br>3 ） 方法调用的点符号与下文一起换行。<br>4 ） 方法调用时，多个参数，需要换行时，在逗号后进行。<br>5 ） 在括号前不要换行，见反例。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span><br><span class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)...</span><br><span class="line">    .append(<span class="string">"huang"</span>)...</span><br><span class="line">    .append(<span class="string">"huang"</span>)...</span><br><span class="line">    .append(<span class="string">"huang"</span>);</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，不要在括号前换行</span></span><br><span class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)...append</span><br><span class="line">    (<span class="string">"huang"</span>);</span><br><span class="line"><span class="comment">// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行</span></span><br><span class="line">method(args1, args2, args3, ...</span><br><span class="line">    , argsX);</span><br></pre></td></tr></table></figure></li><li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。<br>正例：下例中实参的<code>&quot;a&quot;,</code>后边必须要有一个空格。<br><code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></p></li></ol><ol><li>【强制】 IDE 的 text file encoding 设置为 UTF -8 ; IDE 中文件的换行符使用 Unix 格式，<br>不要使用 Windows 格式。</li><li>【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。<br>正例：<br><code>int a = 3;</code><br><code>long b = 4L;</code><br><code>float c = 5F;</code><br><code>StringBuffer sb = new StringBuffer();</code><br>说明：增加 sb 这个变量，如果需要对齐，则给 a 、 b 、 c 都要增加几个空格，在变量比较多的<br>情况下，是非常累赘的事情。</li><li>【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。<br>说明：没有必要插入<code>多个空行</code>进行隔开。</li></ol><h3 id="四-OOP-规约"><a href="#四-OOP-规约" class="headerlink" title="( 四 ) OOP 规约"></a>( 四 ) OOP 规约</h3><ol><li>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成<br>本，直接用<code>类名</code>来访问即可。</li><li>【强制】所有的覆写方法，必须加@ Override 注解。<br>说明： <code>getObject()</code> 与 <code>get0bject()</code> 的问题。一个是字母的 O ，一个是数字的 0，加<code>@Override</code><br>可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编<br>译报错。</li><li>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。<br>说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）<br>正例： <code>public User getUsers(String type, Integer... ids) {...}</code></li><li>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生<br>影响。接口过时必须加<code>@Deprecated</code> 注解，并清晰地说明采用的新接口或者新服务是什么。</li><li>【强制】不能使用过时的类或方法。<br>说明： java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应<br>该使用双参数 decode(String source, String encode) 。接口提供方既然明确是过时接口，<br>那么有义务同时提供新的接口 ； 作为调用方来说，有义务去考证过时方法的新实现是什么。</li><li>【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用<br>equals 。<br>正例：<code>&quot;test&quot;.equals(object);</code><br>反例： <code>object.equals(&quot;test&quot;);</code><br>说明：推荐使用 <code>java.util.Objects#equals</code>（JDK 7 引入的工具类 ）</li><li>【强制】所有的相同类型的包装类对象之间<code>值的比较</code>，全部使用 equals 方法比较。<br>说明：对于 Integer var  = ? 在<code>-128 至 127</code> 范围内的赋值， Integer 对象是在<br>IntegerCache . cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行<br>判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，<br>推荐使用 equals 方法进行判断。</li><li>关于基本数据类型与包装数据类型的使用标准如下：<br>1 ） 【强制】所有的 POJO 类属性必须使用包装数据类型。<br>2 ） 【强制】 RPC 方法的返回值和参数必须使用包装数据类型。<br>3 ） 【推荐】所有的局部变量使用基本数据类型。<br>说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何<br>NPE 问题，或者入库检查，都由使用者来保证。<br>正例：数据库的查询结果可能是 null ，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br>反例：比如显示成交总额涨跌情况，即正负 x %， x 为基本数据类型，调用的 RPC 服务，调用<br>不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装<br>数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</li><li>【强制】定义 DO / DTO / VO 等 POJO 类时，不要设定任何属性<code>默认值</code>。<br>反例： POJO 类的 gmtCreate 默认值为 new Date(); 但是这个属性在数据提取时并没有置入具<br>体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</li><li>【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败 ； 如<br>果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。<br>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</li><li>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</li><li>【强制】 POJO 类必须写 toString 方法。使用 IDE 中的工具： source &gt;  generate toString<br>时，如果继承了另一个 POJO 类，注意在前面加一下 <code>super.toString</code> 。<br>说明：在方法执行抛出异常时，可以直接调用 POJO 的 <code>toString()</code> 方法打印其属性值，便于排<br>查问题。</li><li><p>【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无<br>内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。<br>说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"a,b,c,,"</span>;</span><br><span class="line">String[] ary = str.split(<span class="string">","</span>);</span><br><span class="line"><span class="comment">// 预期大于 3，结果是 3</span></span><br><span class="line">System.out.println(ary.length);</span><br></pre></td></tr></table></figure></li><li><p>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，<br>便于阅读，此条规则优先于第 15 条规则。</p></li></ol><ol><li><p>【推荐】 类内方法定义的顺序依次是：<code>公有方法或保护方法 &gt; 私有方法 &gt;  getter / setter方法</code>。<br>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好 ； 保护方法虽然只是子类<br>关心，也可能是“模板设计模式”下的核心方法 ； 而私有方法外部一般不需要特别关心，是一个<br>黑盒实现 ； 因为承载的信息价值较低，所有 Service 和 DAO 的 getter / setter 方法放在类体<br>最后。</p></li><li><p>【推荐】 setter 方法中，参数名称与类成员变量名称一致， this .成员名 = 参数名。在<br>getter / setter 方法中，不要增加业务逻辑，增加排查问题的难度。<br>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data + <span class="number">100</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data - <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。<br>说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行<br>append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。<br>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"start"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    str = str + <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【推荐】 final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：<br>1） 不允许被继承的类，如： String 类。<br>2） 不允许修改引用的域对象，如： POJO 类的域变量。<br>3） 不允许被重写的方法，如： POJO 类的 setter 方法。<br>4） 不允许运行过程中重新赋值的局部变量。<br>5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好<br>地进行重构。</p></li><li><p>【推荐】慎用 Object 的 clone 方法来拷贝对象。<br>说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象<br>的拷贝。</p></li><li><p>【推荐】类成员与方法访问控制从严：<br>1 ） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 <code>private</code> 。<br>2 ） 工具类不允许有 <code>public 或 default</code> 构造方法。<br>3 ） 类非 static 成员变量并且与子类共享，必须是 <code>protected</code> 。<br>4 ） 类非 static 成员变量并且仅在本类使用，必须是 <code>private</code> 。<br>5 ） 类 static 成员变量如果仅在本类使用，必须是 <code>private</code> 。<br>6 ） 若是 static 成员变量，必须考虑是否为 <code>final</code> 。<br>7 ） 类成员方法只供类内部调用，必须是 <code>private</code> 。<br>8 ） 类成员方法只对继承类公开，那么限制为 <code>protected</code> 。<br>说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。<br>思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员 方法或<br>成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作<br>用域太大，无限制的到处跑，那么你会担心的。</p></li></ol><h3 id="五-集合处理"><a href="#五-集合处理" class="headerlink" title="( 五) 集合处理"></a>( 五) 集合处理</h3><ol><li><p>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：<br>1） 只要重写 equals ，就必须重写 hashCode 。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的<br>对象必须重写这两个方法。<br>3） 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals 。<br>说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象<br>作为 key 来使用。</p></li><li><p>【强制】  ArrayList 的 subList 结果不可强转成 ArrayList ，否则会抛出 ClassCastException<br>异常，即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.<br>说明： subList 返回的是  ArrayList 的内部类  SubList ，并不是  ArrayList ，而是<br>ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p></li><li><p>【强制】在 subList 场景中，<code>高度注意</code>对原集合元素个数的修改，会导致子列表的遍历、增加、<br>删除均会产生 ConcurrentModificationException 异常。</p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array) ，传入的是类型完全一样的数组，大小就是 list.size() 。<br>说明：使用 toArray 带参方法，入参分配的数组空间不够大时， toArray 方法内部将重新分配<br>内存空间，并返回新数组地址 ； 如果数组元素个数大于实际所需，下标为 [ list . size() ]<br>的数组元素将被置为 null ，其它数组元素保持原值，因此最好将方法入参数组大小定义与集<br>合元素个数一致。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="string">"guan"</span>);</span><br><span class="line">list.add(<span class="string">"bao"</span>);</span><br><span class="line">String[] array = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">array = list.toArray(array);</span><br></pre></td></tr></table></figure><p>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[] 类，若强转其它类型数组将出现 ClassCastException 错误。</p></li><li><p>【强制】使用工具类 Arrays . asList() 把数组转换成集合时，不能使用其修改集合相关的方<br>法，它的 add / remove / clear 方法会抛出 UnsupportedOperationException 异常。<br>说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Arrays.asList<br>体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br>String[] str = new String[] { “you”, “wu” };<br>List list = Arrays.asList(str);<br>第一种情况： list.add(“yangguanbao”);  运行时异常。<br>第二种情况： str[0] = “gujin”; 那么 list.get(0) 也会随之修改。</p></li><li><p>【强制】泛型通配符&lt;?  extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方<br>法，而 &lt;? super T&gt; 不能使用 get 方法，作为接口调用赋值时易出错。<br>说明：扩展说一下 PECS(Producer Extends Consumer Super) 原则：第一、频繁往外读取内<br>容的，适合用&lt;?  extends T&gt;。第二、经常往里插入的，适合用 &lt;? super T&gt; 。</p></li><li><p>【强制】不要在 foreach 循环里进行元素的 remove / add 操作。 remove 元素请使用 Iterator<br>方式，如果并发操作，需要对 Iterator 对象加锁。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String item = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"1"</span>.equals(item)) &#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的<br>结果吗？</p></li><li><p>【强制】 在 JDK 7 版本及以上， Comparator 要满足如下三个条件，不然 Arrays . sort ，<br>Collections . sort 会报 IllegalArgumentException 异常。<br>说明：三个条件如下<br>1 ） x ， y 的比较结果和 y ， x 的比较结果相反。<br>2 ） x &gt; y ， y &gt; z ，则 x &gt; z 。<br>3 ） x = y ，则 x ， z 比较结果和 y ， z 比较结果相同。<br>反例：下例中没有处理相等的情况，实际使用中可能会出现异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>【推荐】集合初始化时，指定集合初始值大小。<br>说明： HashMap 使用 HashMap(int initialCapacity) 初始化，<br>正例： initialCapacity = <code>(需要存储的元素个数 / 负载因子) + 1</code>。注意负载因子（即loader<br>factor）默认为 0.75， 如果暂时无法确定初始值大小，请设置为 16（即默认值）。<br>反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容<br>量 7 次被迫扩大， resize 需要重建 hash 表，严重影响性能。</p></li><li><p>【推荐】使用 entrySet 遍历 Map 类集合 KV ，而不是 keySet 方式进行遍历。<br>说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出<br>key 所对应的 value 。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效<br>率更高。如果是 JDK 8，使用 <code>Map.foreach</code> 方法。<br>正例： values() 返回的是 V 值集合，是一个 list 集合对象 ；keySet() 返回的是 K 值集合，是<br>一个 Set 集合对象 ；entrySet() 返回的是 K - V 值组合集合。</p></li><li><p>【推荐】高度注意 Map 类集合 K / V 能不能存储 null 值的情况，如下表格：</p></li></ol><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>不允许为 null</td><td>不允许为 null</td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>不允许为 null</td><td>不允许为 null</td><td>AbstractMap</td><td>锁分段技术（JDK8:CAS）</td></tr><tr><td>TreeMap</td><td>不允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>HashMap</td><td>允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table><p>   反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。</p><ol><li><p>【参考】合理利用好集合的有序性 (sort) 和稳定性 (order) ，避免集合的无序性 (unsort) 和<br>不稳定性 (unorder) 带来的负面影响。<br>说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次<br>序是一定的。如： ArrayList 是 order / unsort；HashMap 是 unorder / unsort；TreeSet 是<br>order / sort 。</p></li><li><p>【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的<br>contains 方法进行遍历、对比、去重操作。</p></li></ol><h3 id="六-并发处理"><a href="#六-并发处理" class="headerlink" title="( 六 ) 并发处理"></a>( 六 ) 并发处理</h3><ol><li><p>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。<br>说明：资源驱动类、工具类、单例工厂类都需要注意。</p></li><li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p></li><li><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明： Executors 返回的线程池对象的弊端如下：<br>1） <code>FixedThreadPool</code> 和 <code>SingleThreadPool</code> :<br>允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。<br>2） <code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>:<br>允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。</p></li><li><p>【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为<br>static ，必须加锁，或者使用 DateUtils 工具类。<br>正例：注意线程安全，使用 DateUtils 。亦推荐如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明：如果是 JDK 8 的应用，可以使用 Instant 代替 Date ， LocalDateTime 代替 Calendar ，<br>DateTimeFormatter 代替 SimpleDateFormat ，官方给出的解释： <code>simple beautiful strongimmutable thread-safe</code> 。</p></li><li><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁 ； 能<br>锁区块，就不要锁整个方法体 ； 能用对象锁，就不要用类锁。<br>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</p></li><li><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造<br>成死锁。<br>说明：线程一需要对表 A 、 B 、 C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序<br>也必须是 A 、 B 、 C ，否则可能出现死锁。</p></li><li><p>【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加<br>锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。<br>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次<br>数不得小于 3 次。</p></li><li><p>【强制】多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，只要其中之一没有捕获<br>抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</p></li><li><p>【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown<br>方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行<br>至 await 方法，直到超时才返回结果。<br>说明：注意，子线程抛出异常堆栈，不能在主线程 try - catch 到。</p></li><li><p>【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一<br>seed 导致的性能下降。<br>说明： Random 实例包括 java . util . Random 的实例或者  Math . random() 的方式。<br>正例：在 JDK 7 之后，可以直接使用 API ThreadLocalRandom ，而在  JDK 7 之前，需要编码保<br>证每个线程持有一个实例。</p></li><li><p>【推荐】在并发场景下，通过双重检查锁 （double-checked locking） 实现延迟初始化的优<br>化问题隐患 ( 可参考  The “Double-Checked Locking is Broken”  Declaration) ，推荐解<br>决方案中较为简单一种 （ 适用于 JDK 5 及以上版本 ） ，将目标属性声明为  volatile 型 。<br>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other methods and fields...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【参考】 volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，<br>但是如果多写，同样无法解决线程安全问题。如果是 count ++操作，使用如下类实现：<br>AtomicInteger count =  new AtomicInteger(); count.addAndGet( 1 );  如果是 JDK 8，推<br>荐使用 <code>LongAdder</code> 对象，比 AtomicLong 性能更好 （ 减少乐观锁的重试次数 ） 。</p></li><li><p>【参考】  HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在<br>开发过程中可以使用其它数据结构或加锁来规避此风险。</p></li><li><p>【参考】 ThreadLocal 无法解决共享对象的更新问题， ThreadLocal 对象建议使用 static<br>修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享<br>此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象 ( 只<br>要是这个线程内定义的 ) 都可以操控这个变量。</p></li></ol><h3 id="七-控制语句"><a href="#七-控制语句" class="headerlink" title="( 七 ) 控制语句"></a>( 七 ) 控制语句</h3><ol><li><p>【强制】在一个 switch 块内，每个 case 要么通过 break / return 等来终止，要么注释说明程<br>序将继续执行到哪一个 case 为止 ； 在一个 switch 块内，都必须包含一个 default 语句并且<br>放在最后，即使空代码。</p></li><li><p>【强制】在 if / else / for / while / do 语句中必须使用大括号。即使只有一行代码，避免采用<br>单行的编码方式： if (condition) statements;</p></li><li><p>【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。<br>说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间<br>判断条件来代替。<br>反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变<br>成了负数，这样的话，活动无法终止。</p></li><li><p>【推荐】表达异常的分支时，少用 if-else 方式 ，这种方式可以改写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着写 else 的业务逻辑代码;</span></span><br></pre></td></tr></table></figure><p>说明：如果非得使用 if()…else if()…else… 方式表达逻辑，【强制】避免后续代码维<br>护困难，请勿超过 3 层。<br>正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，<br>其中卫语句示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">today</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBusy()) &#123;</span><br><span class="line">        System.out.println(“change time.”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFree()) &#123;</span><br><span class="line">        System.out.println(“go to travel.”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【推荐】除常用方法（如 getXxx/isXxx ）等外，不要在条件判断中执行其它复杂的语句，将复<br>杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。<br>说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么<br>样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) ||(...);</span><br><span class="line"><span class="keyword">if</span> (existed) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、<br>获取数据库连接，进行不必要的 try - catch 操作 （ 这个 try - catch 是否可以移至循环体外 ） 。</p></li><li><p>【推荐】避免采用取反逻辑运算符。<br>说明：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法。<br>正例：使用 if (x &lt; 628)  来表达 x 小于 628。<br>反例：使用 if (!(x &gt;= 628))  来表达 x 小于 628。</p></li><li><p>【推荐】接口入参保护，这种场景常见的是用作批量操作的接口。</p></li><li><p>【参考】下列情形，需要进行参数校验：<br>1 ） 调用频次低的方法。<br>2 ） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参<br>数错误导致中间执行回退，或者错误，那得不偿失。<br>3 ） 需要极高稳定性和可用性的方法。<br>4 ） 对外提供的开放接口，不管是 RPC / API / HTTP 接口。<br>5） 敏感权限入口。</p></li><li><p>【参考】下列情形，不需要进行参数校验：<br>1 ） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。<br>2 ） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底<br>层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所<br>以 DAO 的参数校验，可以省略。<br>3 ） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参<br>数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p></li></ol><h3 id="八-注释规约"><a href="#八-注释规约" class="headerlink" title="( 八 ) 注释规约"></a>( 八 ) 注释规约</h3><ol><li><p>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/<em>*内容</em>/格式，不得使用<br>//  xxx 方式。<br>说明：在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注<br>释 ； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高<br>阅读效率。</p></li><li><p>【强制】所有的抽象方法 （ 包括接口中的方法 ） 必须要用 Javadoc 注释、除了返回值、参数、<br>异常说明外，还必须指出该方法做什么事情，实现什么功能。<br>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p></li><li><p>【强制】所有的类都必须添加创建者和创建日期。</p></li><li><p>【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释<br>使用/<em> </em>/注释，注意与代码对齐。</p></li><li><p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p></li><li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持<br>英文原文即可。<br>反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p></li><li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑<br>等的修改。<br>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，<br>就失去了导航的意义。</p></li><li><p>【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。<br>说明：代码被注释掉有两种可能性：1 ） 后续会恢复此段代码逻辑。2 ） 永久不用。前者如果没<br>有备注信息，难以知晓注释动机。后者建议直接删掉 （ 代码仓库保存了历史代码 ） 。</p></li><li><p>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑 ； 第二、能够描述业务含<br>义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同<br>天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路 ； 注释也是给继任者看<br>的，使其能够快速接替自己的工作。</p></li><li><p>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的<br>一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put elephant into fridge</span></span><br><span class="line">put(elephant, fridge);</span><br></pre></td></tr></table></figure><p>方法名 put ，加上两个有意义的变量名 elephant 和 fridge ，已经说明了这是在干什么，语<br>义清晰的代码不需要额外的注释。</p></li><li><p>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，<br>经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1 ） 待办事宜 （TODO） : （ 标记人，标记时间， [ 预计处理时间 ]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc<br>还没有实现，但已经被广泛使用。只能应用于类，接口和方法 （ 因为它是一个 Javadoc 标签 ） 。<br>2 ） 错误，不能工作 （FIXME） : （ 标记人，标记时间， [ 预计处理时间 ]）<br>在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;《阿里巴巴Java开发手册》是阿里巴巴集团技术团队的集体智慧结晶和经验总&lt;br&gt;结，经历了多次大规模一线实战的检验及不断的完善，系统化地整理成册，回馈给广&lt;br&gt;大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是&lt;br&gt;编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表&lt;br&gt;结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续&lt;br&gt;维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以Java开发者为中心&lt;br&gt;视角，划分为编程规约、异常日志、单元测试、安全规约、工程结构、MySQL数据库六&lt;br&gt;个维度，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，&lt;br&gt;规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内&lt;br&gt;容做了适当扩展和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要&lt;br&gt;提防的雷区，以及真实的错误案例。&lt;br&gt;本手册的愿景是码出高效，码出质量。现代软件架构都需要协同开发完成，高效&lt;br&gt;协作即降低协同成本，提升沟通效率，所谓无规矩不成方圆，无规范不能协作。众所&lt;br&gt;周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如&lt;br&gt;果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是&lt;br&gt;消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式&lt;br&gt;一起做事，提升协作效率。代码的字里行间流淌的是软件生命中的血液，质量的提升&lt;br&gt;是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="编程规约" scheme="http://dijia478.cn/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器上安装JDK小白教程</title>
    <link href="http://dijia478.cn//blog/2017/06/07/2017-06-07-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85JDK%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/"/>
    <id>http://dijia478.cn//blog/2017/06/07/2017-06-07-Linux服务器上安装JDK小白教程/</id>
    <published>2017-06-07T06:55:37.000Z</published>
    <updated>2018-01-02T04:16:54.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><p>VMware12 Pro</p><p>CentOS-6.7-i386-bin-DVD1</p><p>jdk-8u151-linux-i586</p><h2 id="二、详细安装步骤"><a href="#二、详细安装步骤" class="headerlink" title="二、详细安装步骤"></a>二、详细安装步骤</h2><h3 id="前提：需要卸载已经装过的jdk"><a href="#前提：需要卸载已经装过的jdk" class="headerlink" title="前提：需要卸载已经装过的jdk"></a>前提：需要卸载已经装过的jdk</h3><a id="more"></a><p>rpm -qa | grep jdk        会显示你所有包含jdk这个字符串的安装包</p><p>rpm -e –nodeps 对应的每个包名        会卸载对应的包</p><p>之后如果输入<code>java -version</code>命令后显示<code>command not found</code>，就是卸载完了。我之前是装过jdk1.7的，所以我需要卸载 ，从来没装过jdk的直接从下面开始</p><h3 id="1-去官网下载JDK"><a href="#1-去官网下载JDK" class="headerlink" title="1. 去官网下载JDK"></a>1. 去官网下载JDK</h3><p> <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>需要选中那个图中红色框起来的小圆点，才能下在，意思就是你接收许可协议</p><p>因为我的虚拟系统是32位的，所以我下32位JDK，根据你的情况具体看。x86代表32位系统，x64代表64位系统。</p><p>不知道服务器是多少位系统的，直接用这个命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure><img src="/blog/2017/06/07/2017-06-07-Linux服务器上安装JDK小白教程/jdk01.png"><h3 id="2-上传，解压JDK"><a href="#2-上传，解压JDK" class="headerlink" title="2. 上传，解压JDK"></a>2. 上传，解压JDK</h3><p>有人可能不知到怎么上传文件到服务器上，这里我推荐个软件，叫<code>lrzsz</code></p><p>这是一个简单的linux服务器上传下载工具，如果你没装过的话，可以装一下，挺好用的</p><p>安装前先检查有没有安装lrzsz：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm –q lrzsz</span><br></pre></td></tr></table></figure><p>没安装可以使用下列命令进行安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>之后你就可以用rz命令上传本地文件到服务器的当前目录下了，sz命令后面跟上指定文件目录，可以将其从服务器上下载到本地</p><p>好了，用rz命令上传好jdk的tar包后，需要解压，执行如下命令，可能你用的版本和我不一样，注意后面是你自己上传的jdk的包名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxf jdk<span class="number">-8</span>u151-linux-i586.tar.gz</span><br></pre></td></tr></table></figure><h3 id="3-移动下位置"><a href="#3-移动下位置" class="headerlink" title="3. 移动下位置"></a>3. 移动下位置</h3><p>为了以后方便管理，我把jdk的目录换个位置，重命名一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv jdk1.8.0_151 /usr/share/jdk1.8</span><br></pre></td></tr></table></figure><h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4. 配置环境变量"></a>4. 配置环境变量</h3><p>用vim打开<code>/etc/profile</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件最下面添加下面的语句，保存退出（按ESC，然后输入，英文冒号wq英文感叹号（:wq!），按回车）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/share/jdk1<span class="number">.8</span></span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure><p>执行下面的命令让配置立即生效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>现在输入<code>java -version</code>命令，如果显示<code>java version &quot;1.8.0_151&quot;</code>，就是ok了</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、环境&quot;&gt;&lt;a href=&quot;#一、环境&quot; class=&quot;headerlink&quot; title=&quot;一、环境&quot;&gt;&lt;/a&gt;一、环境&lt;/h2&gt;&lt;p&gt;VMware12 Pro&lt;/p&gt;
&lt;p&gt;CentOS-6.7-i386-bin-DVD1&lt;/p&gt;
&lt;p&gt;jdk-8u151-linux-i586&lt;/p&gt;
&lt;h2 id=&quot;二、详细安装步骤&quot;&gt;&lt;a href=&quot;#二、详细安装步骤&quot; class=&quot;headerlink&quot; title=&quot;二、详细安装步骤&quot;&gt;&lt;/a&gt;二、详细安装步骤&lt;/h2&gt;&lt;h3 id=&quot;前提：需要卸载已经装过的jdk&quot;&gt;&lt;a href=&quot;#前提：需要卸载已经装过的jdk&quot; class=&quot;headerlink&quot; title=&quot;前提：需要卸载已经装过的jdk&quot;&gt;&lt;/a&gt;前提：需要卸载已经装过的jdk&lt;/h3&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://dijia478.cn/categories/Linux/"/>
    
    
      <category term="JDK" scheme="http://dijia478.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>关于异常处理的一些建议</title>
    <link href="http://dijia478.cn//blog/2017/02/02/2017-02-02-%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/"/>
    <id>http://dijia478.cn//blog/2017/02/02/2017-02-02-关于异常处理的一些建议/</id>
    <published>2017-02-02T04:08:02.000Z</published>
    <updated>2018-01-03T03:01:52.687Z</updated>
    
    <content type="html"><![CDATA[<p>合理地使用异常处理可以帮你节省数小时（甚至数天）调试时间。一个乘法异常会毁掉你的晚餐乃至周末计划。如果处置不及时，甚至对你的名誉都会造成影响。一个清晰的异常处理策略可以助你节省诊断、重现和问题纠正时间。下面是我工作中总结的6条异常处理建议。</p><h2 id="一、使用一个系统全局异常类"><a href="#一、使用一个系统全局异常类" class="headerlink" title="一、使用一个系统全局异常类"></a>一、使用一个系统全局异常类</h2><p>不必为每种异常类型建立单独的类，一个就够了。确保这个异常类继承RuntimeException，这样可以减少类个数并且移除不必要的异常声明。</p><p>我知道你正在想什么：如果类型只有一个，那么怎么能知道异常具体是什么？我将如何追踪具体的属性？请继续往下看。<br><a id="more"></a></p><h2 id="二、使用枚举错误码"><a href="#二、使用枚举错误码" class="headerlink" title="二、使用枚举错误码"></a>二、使用枚举错误码</h2><p>我们大多被教授的方法是将异常转为错误信息。这在查看日志文件时很好，（呃）但是这样也有缺点：</p><ol><li>错误信息不会被翻译（除非你是Google）</li><li>错误信息不会转换为用户友好的文字</li><li>错误信息不能用编程的方式检测</li></ol><p>将异常消息留给开发者定义也会出现同样的错误有多种不同的描述。</p><p>一个更好的办法是使用枚举表示异常类型。为每个错误分类创建一个枚举（付款、认证等），让枚举实现ErrorCode接口并作为异常的一个属性。</p><p>当抛出异常时，只要传入合适的枚举就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SystemException(PaymentCode.CREDIT_CARD_EXPIRED);</span><br></pre></td></tr></table></figure><p>现在如果需要测试异常只要比较异常代码和枚举就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (SystemException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.getErrorCode() == PaymentCode.CREDIT_CARD_EXPIRED) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将错误码作为查找资源的key就可以方便地提供友好的国际化文本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemExceptionExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getUserText(ValidationCode.VALUE_TOO_SHORT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserText</span><span class="params">(ErrorCode errorCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = errorCode.getClass().getSimpleName() + <span class="string">"__"</span> + errorCode;</span><br><span class="line">        ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">"cn.dijia478.exception.example.exceptions"</span>);</span><br><span class="line">        <span class="keyword">return</span> bundle.getString(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、为枚举添加错误值"><a href="#三、为枚举添加错误值" class="headerlink" title="三、为枚举添加错误值"></a>三、为枚举添加错误值</h2><p>在很多时候可以为异常添加错误值，比如HTTP返回值。这种情况下，可以在ErrorCode接口添加一个getNumber方法并在每个枚举中实现这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PaymentCode implements ErrorCode &#123;</span><br><span class="line"></span><br><span class="line">    SERVICE_TIMEOUT(<span class="number">101</span>),</span><br><span class="line"></span><br><span class="line">    CREDIT_CARD_EXPIRED(<span class="number">102</span>),</span><br><span class="line"></span><br><span class="line">    AMOUNT_TOO_HIGH(<span class="number">103</span>),</span><br><span class="line"></span><br><span class="line">    INSUFFICIENT_FUNDS(<span class="number">104</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PaymentCode</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加错误码可以是全局数值也可以每个枚举自己负责。你可以直接使用枚举里的ordinal()方法或者从文件或数据库加载。</p><h2 id="四、为异常添加动态属性"><a href="#四、为异常添加动态属性" class="headerlink" title="四、为异常添加动态属性"></a>四、为异常添加动态属性</h2><p>好的异常处理还应该记录相关数据而不仅仅是堆栈信息，这样可以在诊断错误和重现错误时节省大量时间。用户不会在你的应用停止工作时告诉你他们到底做了什么。</p><p>最简单的办法是给异常添加一个java.util.Map字段。新字段的职责就是通过名字保存相关数据。通过添加setter方法可以遵循流式接口。</p><p>可以像下面示例这样添加相关数据并抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SystemException(ValidationCode.VALUE_TOO_SHORT)</span><br><span class="line">    .set(<span class="string">"field"</span>, field)</span><br><span class="line">    .set(<span class="string">"value"</span>, value)</span><br><span class="line">    .set(<span class="string">"min-length"</span>, MIN_LENGTH);</span><br></pre></td></tr></table></figure><h2 id="五、避免不必要的嵌套"><a href="#五、避免不必要的嵌套" class="headerlink" title="五、避免不必要的嵌套"></a>五、避免不必要的嵌套</h2><p>冗长的堆栈信息不会有任何帮助，更糟糕的是会浪费你的时间和资源。重新抛出异常时调用静态函数而不是异常构造函数。封装的静态函数决定什么时候嵌套异常什么时候只要返回原来的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SystemException <span class="title">wrap</span><span class="params">(Throwable exception, ErrorCode errorCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> SystemException) &#123;</span><br><span class="line">        SystemException se = (SystemException) exception;</span><br><span class="line">        <span class="keyword">if</span> (errorCode != <span class="keyword">null</span> &amp;&amp; errorCode != se.getErrorCode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SystemException(exception.getMessage(), exception, errorCode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> se;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SystemException(exception.getMessage(), exception, errorCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SystemException <span class="title">wrap</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(exception, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新抛出异常的新代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> SystemException.wrap(e).set(<span class="string">"fileName"</span>, fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、使用带Web支持的集中式logger"><a href="#六、使用带Web支持的集中式logger" class="headerlink" title="六、使用带Web支持的集中式logger"></a>六、使用带Web支持的集中式logger</h2><p>再额外附赠一个建议。可能你情况很难向产品记录日志，这个麻烦可能来自多个中间商（很多开发者不能直接访问产品环境）。</p><p>在多服务器环境下情况可能会更糟。找到正确的服务器或者确定问题影响到了哪个服务器是一件非常令人头痛的事情。</p><p>我的建议是：</p><ol><li>将你的日志记录到一个地方，推荐记录到数据库中。</li><li>通过Web浏览器访问数据库。</li></ol><p>有很多方法和备选产品可以达成这一目标，log collector、远程logger、JMX agent、系统监视软件等。好处就是：</p><ul><li>几秒钟之内定位错误</li><li>为每个异常增加一个URL，可以记录或者发送email</li><li>让你的小伙伴可以在没有你的情况下定位错误原因</li><li>避免测试人员为同一个bug添加多个记录。他们可以在bug记录里增加一条异常URL</li><li>省钱</li><li>让你的周末和名誉不受影响</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合理地使用异常处理可以帮你节省数小时（甚至数天）调试时间。一个乘法异常会毁掉你的晚餐乃至周末计划。如果处置不及时，甚至对你的名誉都会造成影响。一个清晰的异常处理策略可以助你节省诊断、重现和问题纠正时间。下面是我工作中总结的6条异常处理建议。&lt;/p&gt;
&lt;h2 id=&quot;一、使用一个系统全局异常类&quot;&gt;&lt;a href=&quot;#一、使用一个系统全局异常类&quot; class=&quot;headerlink&quot; title=&quot;一、使用一个系统全局异常类&quot;&gt;&lt;/a&gt;一、使用一个系统全局异常类&lt;/h2&gt;&lt;p&gt;不必为每种异常类型建立单独的类，一个就够了。确保这个异常类继承RuntimeException，这样可以减少类个数并且移除不必要的异常声明。&lt;/p&gt;
&lt;p&gt;我知道你正在想什么：如果类型只有一个，那么怎么能知道异常具体是什么？我将如何追踪具体的属性？请继续往下看。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="异常" scheme="http://dijia478.cn/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Redis的五种数据类型及Jedis方法</title>
    <link href="http://dijia478.cn//blog/2016/09/04/2016-09-04-Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%96%B9%E6%B3%95/"/>
    <id>http://dijia478.cn//blog/2016/09/04/2016-09-04-Redis的五种数据类型及方法/</id>
    <published>2016-09-04T15:18:47.000Z</published>
    <updated>2017-12-31T17:18:29.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串string："><a href="#字符串string：" class="headerlink" title="字符串string："></a>字符串string：</h2><p>字符串string是Redis中最为基础的数据存储类型，是一个由字节组成的序列，他在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据货Json对象描述信息等，是标准的key-value，一般来存字符串，整数和浮点数。Value最多可以容纳的数据长度为512MB<br>应用场景：很常见的场景用于统计网站访问数量，当前在线人数等。incr命令(++操作)<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set(key, value)<span class="comment">// set设置相同的键时,后一个值会覆盖前面的值</span></span><br><span class="line">get(key)<span class="comment">// 获取key对应的value</span></span><br><span class="line">setnx(key, value)<span class="comment">// nx:表示not exists,如果key不存在就设置,如果存在就不设置</span></span><br><span class="line">setrange(key, startIndex, vlaue)<span class="comment">// 替换字符串,表示把指定的key的值从开始索引开始是value这个值进行替换</span></span><br><span class="line">mset(key1, value1, key2, value2, ...)<span class="comment">// 批量设置键值对</span></span><br><span class="line">msetnx(key1, value1, key2, value2, ...)<span class="comment">// 如果key已存在那么设置失败</span></span><br><span class="line">getset(key, newValue)<span class="comment">// 获取key的值然后设置新的值</span></span><br><span class="line">getrange(key, startIndex, endIndex)<span class="comment">// 获取数据,最后一个值的索引为-1</span></span><br><span class="line">mget(key1, key2, key3, ...)<span class="comment">// 批量获取</span></span><br><span class="line">incr(key)<span class="comment">// 自增1</span></span><br><span class="line">incrby(key, num)<span class="comment">// 指定增减的数量</span></span><br><span class="line">decr(key)<span class="comment">// 自减1</span></span><br><span class="line">decrby(key, num)<span class="comment">// 指定自增减的数量</span></span><br><span class="line">append(key, value)<span class="comment">// 给指定的字符串追加value的值</span></span><br><span class="line">strlen(key)<span class="comment">// 获取指定的key对应的值得长度</span></span><br></pre></td></tr></table></figure><h2 id="列表list："><a href="#列表list：" class="headerlink" title="列表list："></a>列表list：</h2><p>Redis的列表list允许用户从序列的两端推入或者弹出元素，列表由多个字符串值组成的有序可重复的序列，是链表结构，类似于Java中的List集合，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。List中可以包含的最大元素数量是4294967295。<br>应用场景：1.最新消息排行榜。2.消息队列，以完成多程序之间的消息交换。可以用push操作将任务存在list中（生产者），然后线程在用pop操作将任务取出进行执行。（消费者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lpush(key, value1, value2, ...)<span class="comment">// 往list集合中压入元素</span></span><br><span class="line">linsert(key, before/after, value, newValue)<span class="comment">// 在指定的元素前或者后插入元素</span></span><br><span class="line">lset(key, index, newValue)<span class="comment">// 设置指定下标的值</span></span><br><span class="line">lrem(key, count, value)<span class="comment">// 删除count个于value相同的元素,count&gt;0从开始位置进行删除,count&lt;0从末尾开始删除,count=0删除所有的</span></span><br><span class="line">ltrim(key, startIndex, endIndex)<span class="comment">// 删除指定范围内以外的元素,保留指定范围内的元素</span></span><br><span class="line">lpop(key)<span class="comment">// 从list的头部删除元素</span></span><br><span class="line">lindex(key, index)<span class="comment">// 返回指定索引处的元素</span></span><br><span class="line">llen(key)<span class="comment">// 返回列表的长度</span></span><br><span class="line">rpush(key, value)<span class="comment">// 从末尾压入元素</span></span><br><span class="line">rpop(key)<span class="comment">// 从末尾删除元素</span></span><br><span class="line">rpoplpush(key1, key2)<span class="comment">// 从key1链表中弹出最后一个元素然后压入到key2链表中</span></span><br></pre></td></tr></table></figure><h2 id="散列hash："><a href="#散列hash：" class="headerlink" title="散列hash："></a>散列hash：</h2><p>Redis中的散列hash可以看成具有String key和String value的map容器，可以将多个key-value存储到一个key中。每一个Hash可以存储4294967295个键值对。hash特别适用于存储对象, 将一个对象存在hash中相对于存储在String可以节省更多的内存。<br>应用场景：例如存储、读取、修改用户属性（name，age，pwd等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hset(key, field, value)<span class="comment">// 给指定的key添加key-value元素</span></span><br><span class="line">hget(key, field)<span class="comment">// 获取指定的key中filed字段的值</span></span><br><span class="line">hsetnx(key, field, value)<span class="comment">// 如果key不存在进行插入,如果key和field都存在不进行插入</span></span><br><span class="line">hexists(key, field)<span class="comment">// 判断指定的key中是否存在field这个字段</span></span><br><span class="line">hlen(key)<span class="comment">// 获取指定的key中字段的数量</span></span><br><span class="line">hdel(key, field1, field2, ...)<span class="comment">// 删除指定的key中的指定的字段的和对应的值</span></span><br><span class="line">hincrby(key, filed, count)<span class="comment">// 给指定的key的field的字段添加或者减去count这个值</span></span><br><span class="line">hgetall(key)<span class="comment">// 获取key中所有的键值对,返回的是一个键一个值</span></span><br><span class="line">hkeys(key)<span class="comment">// 获取指定的key中所有的字段</span></span><br><span class="line">hmget(key, field1, field2, ...)<span class="comment">// 获取指定的key中指定字段的值</span></span><br><span class="line">hmset(key, field1, value1, field2, value2, ...)<span class="comment">// 同时设置多个键值对数据</span></span><br><span class="line">hvals(key)<span class="comment">// 获取指定的key中所有的value</span></span><br><span class="line">hincrbyfloat(key field value)<span class="comment">// 给指定的字段添加浮点数的值</span></span><br></pre></td></tr></table></figure><h2 id="集合set："><a href="#集合set：" class="headerlink" title="集合set："></a>集合set：</h2><p>Redis的集合set是无序不可重复的，和列表一样，在执行插入和删除和判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集差集操作。Set可包含的最大元素数量是4294967295。<br>应用场景：1.利用交集求共同好友。2.利用唯一性，可以统计访问网站的所有独立IP。3.好友推荐的时候根据tag求交集，大于某个threshold（临界值的）就可以推荐。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sadd(key, member1, member2, ...)<span class="comment">// 添加元素</span></span><br><span class="line">scard(key)<span class="comment">// 获取成员的数量</span></span><br><span class="line">sismember(key, member)<span class="comment">// 判断是否存在member这个成员</span></span><br><span class="line">smembers(key)<span class="comment">// 获取所有的成员</span></span><br><span class="line">spop(key)<span class="comment">// 随机弹出一个成员</span></span><br><span class="line">srandmember(key, [count])<span class="comment">// 随机获取一个或者多个成员 </span></span><br><span class="line">srem(key, member1, member2, ...)<span class="comment">// 删除一个或者多个成员,如果成员不存在则忽略</span></span><br><span class="line">smove(source, desition, member)<span class="comment">// 移动一个成员到指定的set中</span></span><br><span class="line">sdiff(first-key, key1, key2, ...)<span class="comment">// 返回给定集合之间的差集。不存在的集合 key 将视为空集</span></span><br><span class="line">sdiffstore(destionset, key1, key2, ...)<span class="comment">// 把获取到的差集保存到目标set中</span></span><br><span class="line">sinter(key1, key2, ...)<span class="comment">// 获取交集</span></span><br><span class="line">sinterstore(destionset, key1, key2, ...)<span class="comment">// 把获取到的交集存储到目标set中</span></span><br><span class="line">sunion(key1, key2, ...)<span class="comment">// 获取并集</span></span><br><span class="line">sunionstore(destionset, key1, key2, ...)<span class="comment">// 把获取到的并集存储到目标set中</span></span><br></pre></td></tr></table></figure><h2 id="有序集合sorted-set："><a href="#有序集合sorted-set：" class="headerlink" title="有序集合sorted set："></a>有序集合sorted set：</h2><p>Redis的有序集合sorted set和集合set一样，都是字符串的集合，都不允许重复的成员出现在一个set中。他们之间差别在于有序集合中每一个成员都会有一个double类型的分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。尽管有序集合中的成员必须是唯一的，但是分数(score)却可以重复。<br>应用场景：可以用于一个大型在线游戏的积分排行榜，每当玩家的分数发生变化时，可以执行zadd更新玩家分数(score)，此后在通过zrange获取几分top ten的用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zadd(key, score1, member1, score2, member2, ...)<span class="comment">// 用于将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。注意： 在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。</span></span><br><span class="line">zcard(key)<span class="comment">// 计算元素个数</span></span><br><span class="line">zincrby(key, number, member)<span class="comment">// 给指定的member的分数添加或者减去number这个值，当 key 不存在，或分数不是 key 的成员时，ZINCRBY key number member 等同于 ZADD key number member 。当 key 不是有序集类型时，返回一个错误。分数值可以是整数值或双精度浮点数。</span></span><br><span class="line">zcount(key, min, max)<span class="comment">// 获取分数在min和max之间的成员和数量; 默认是闭区间; 想不包含可以: (min (max</span></span><br><span class="line">zrange(key, start, stop, [WITHSCORES])<span class="comment">// 返回指定排名之间的成员(结果是分数由低到高)，排名以0开始</span></span><br><span class="line">zrevrange(key, start, stop, [WITHSCORES])<span class="comment">// 返回指定排名之间的成员(结果是分数由高到低)</span></span><br><span class="line">zrangebyscore(key, min, max, [withscores], [limit offset count])<span class="comment">// 根据分数的范围获取成员(按照分数: 从低到高)</span></span><br><span class="line">zrevrangebyscore(key, max, min, [withscores], [limit offset count])<span class="comment">// 根据分数的范围获取成员(从高到低)</span></span><br><span class="line">zrank(key, member)<span class="comment">// 返回一个成员的排名(从低到高的顺序)</span></span><br><span class="line">zrevrank(key, member)<span class="comment">// 返回一个成员的排名(从高到低)</span></span><br><span class="line">zscore(key, member)<span class="comment">// 获取一个成员的分数</span></span><br><span class="line">zrem(key, member1, member2...)<span class="comment">// 删除指定的成员</span></span><br><span class="line">zremrangebyrank(key, start, stop)<span class="comment">// 根据排名进行删除</span></span><br><span class="line">zremrangebyscore(key, min, max)<span class="comment">// 根据分数的范围进行删除</span></span><br></pre></td></tr></table></figure><h2 id="对key的通用操作"><a href="#对key的通用操作" class="headerlink" title="对key的通用操作"></a>对key的通用操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">keys(pattern)<span class="comment">// 根据指定的规则返回符合条件的key</span></span><br><span class="line">del(key1, key2, ...)<span class="comment">// 删除指定的key</span></span><br><span class="line">exists(key)<span class="comment">// 判断是否存在指定的key</span></span><br><span class="line">move(key, db)<span class="comment">// 将指定的key移入到指定的数据库中，redis默认存在16个库select 10:表示选择9号库</span></span><br><span class="line">rename(key, newkey)<span class="comment">// 对key进行重命名</span></span><br><span class="line">renamenx(key, newkey)<span class="comment">// 仅当 newkey 不存在时，将 key 改名为 newkey</span></span><br><span class="line">type(key)<span class="comment">// 返回key的类型</span></span><br><span class="line">expire(key, second)<span class="comment">// 给指定的key设置失效时间</span></span><br><span class="line">expireat(key, timestamp)<span class="comment">// 以时间戳的形式设置key的失效时间</span></span><br><span class="line">pexpireat(key, timestamp)<span class="comment">// 以毫秒为单位设置key的失效时间</span></span><br><span class="line">persist(key)<span class="comment">// 移除key的失效时间</span></span><br><span class="line">ttl(key)<span class="comment">// 以秒为单位返回key的剩余时间(返回-2表示key不存在, 返回-1表示永远不过时)</span></span><br><span class="line">pttl(key)<span class="comment">// 一毫秒为单位返回key的失效时间</span></span><br><span class="line">randomkey() <span class="comment">// 随机返回一个key</span></span><br><span class="line">dump(key)<span class="comment">// 序列化给定 key</span></span><br><span class="line">flushdb()<span class="comment">// 删除当前选择数据库中的所有key</span></span><br><span class="line">flushall()<span class="comment">// 删除所有数据库中的所有key</span></span><br></pre></td></tr></table></figure><p><a href="http://tool.oschina.net/uploads/apidocs/" target="_blank" rel="noopener">Jedis API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串string：&quot;&gt;&lt;a href=&quot;#字符串string：&quot; class=&quot;headerlink&quot; title=&quot;字符串string：&quot;&gt;&lt;/a&gt;字符串string：&lt;/h2&gt;&lt;p&gt;字符串string是Redis中最为基础的数据存储类型，是一个由字节组成的序列，他在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据货Json对象描述信息等，是标准的key-value，一般来存字符串，整数和浮点数。Value最多可以容纳的数据长度为512MB&lt;br&gt;应用场景：很常见的场景用于统计网站访问数量，当前在线人数等。incr命令(++操作)&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="Redis" scheme="http://dijia478.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>如何抽取代码后，在父类实例化泛型的问题</title>
    <link href="http://dijia478.cn//blog/2016/08/18/2016-08-18-%E5%A6%82%E4%BD%95%E6%8A%BD%E5%8F%96%E4%BB%A3%E7%A0%81%E5%90%8E%EF%BC%8C%E5%9C%A8%E7%88%B6%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://dijia478.cn//blog/2016/08/18/2016-08-18-如何抽取代码后，在父类实例化泛型的问题/</id>
    <published>2016-08-18T13:10:45.000Z</published>
    <updated>2018-01-03T04:10:51.909Z</updated>
    
    <content type="html"><![CDATA[<p>代码背景：有大量的action类中需要使用模型驱动，所以会抽取公共部分代码，</p><p>但由于action类要实现ModelDriven<t>接口，抽取成BaseAction里面的泛型T如何在子类实例化的问题。<a id="more"></a></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽取Action的公共代码 ，简化开发</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dijia478</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0，2017-8-30 20:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 模型驱动 */</span></span><br><span class="line">    <span class="keyword">protected</span> T model;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器 完成model实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造子类Action对象 ，获取继承父类型的泛型</span></span><br><span class="line">        <span class="comment">// AreaAction extends BaseAction&lt;Area&gt;</span></span><br><span class="line">        <span class="comment">// BaseAction&lt;Area&gt;</span></span><br><span class="line">        Type genericSuperclass = <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">// 获取类型第一个泛型参数</span></span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">        Class&lt;T&gt; modelClass = (Class&lt;T&gt;) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            model = modelClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"模型构造失败..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是通过构造器来实例化泛型T的，子类要继承BaseAction，加载子类的时候，子类构造默认会调用supper();，所以会将泛型T实例化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码背景：有大量的action类中需要使用模型驱动，所以会抽取公共部分代码，&lt;/p&gt;
&lt;p&gt;但由于action类要实现ModelDriven&lt;t&gt;接口，抽取成BaseAction里面的泛型T如何在子类实例化的问题。
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="泛型" scheme="http://dijia478.cn/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://dijia478.cn//blog/2016/05/13/2016-05-13-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://dijia478.cn//blog/2016/05/13/2016-05-13-Linux常用命令/</id>
    <published>2016-05-13T04:32:56.000Z</published>
    <updated>2018-01-02T04:18:52.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、系统目录结构"><a href="#一、系统目录结构" class="headerlink" title="一、系统目录结构"></a>一、系统目录结构</h2><img src="/blog/2016/05/13/2016-05-13-Linux常用命令/linux01.png"><p>约定俗成：</p><p>  bin (binaries)存放二进制可执行文件<br>  etc (etcetera)存放系统配置文件<br>  usr (unix shared resources)用于存放共享的系统资源<br>  home 存放用户文件的根目录<br>  root 超级用户目录<br><a id="more"></a><br>  sbin (super user binaries)存放二进制可执行文件，只有root才能访问<br>  dev (devices)用于存放设备文件<br>  lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块<br>  mnt (mount)系统管理员安装临时文件系统的安装点<br>  boot 存放用于系统引导时使用的各种文件<br>  tmp (temporary)用于存放各种临时文件<br>  var (variable)用于存放运行时需要改变数据的文件</p><h2 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h2><p><strong>加粗命令为本人比较常用的命令（会经常更新）</strong></p><h3 id="1-目录操作"><a href="#1-目录操作" class="headerlink" title="1.目录操作"></a>1.目录操作</h3><p>相对路径和绝对路径说明：</p><p>现在在/home/dijia478/下<br>./a/b.txt和a/b.txt都表示相对路径，当前目录下的a文件夹下的b.txt文件<br>/home/dijia478/a/b.txt表示绝对路径，根目录下的home文件夹下的dijia478文件夹下的a文件夹下的b.txt文件</p><p><strong>cd ./a    切换到当前目录的a文件夹</strong><br><strong>cd ..    切换到上一层目录</strong><br><strong>cd /    切换到系统根目录</strong><br><strong>cd ~    切换到用户主目录</strong><br><strong>cd -    切换到上一个所在目录</strong><br><strong>pwd    显示当前所在目录的绝对路径</strong></p><h3 id="2-查看文件列表"><a href="#2-查看文件列表" class="headerlink" title="2.查看文件列表"></a>2.查看文件列表</h3><p><strong>ls /path/    显示该目录所有文件或文件夹名</strong><br><strong>ls -a    显示所有文件或文件夹名（包含隐藏的）</strong><br><strong>ls -l    按列表显示所有文件或文件夹，缩写成ll</strong></p><p>ll -h    友好的显示文件大小（显示成K，MB，GB）</p><h3 id="3-创建和删除文件夹"><a href="#3-创建和删除文件夹" class="headerlink" title="3.创建和删除文件夹"></a>3.创建和删除文件夹</h3><p><strong>mkdir app    创建app文件夹</strong><br><strong>mkdir –p app2/test    级联创建aap2以及test文件夹</strong></p><p>rmdir app    删除app目文件夹（需要是空文件夹）</p><h3 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4.文件操作"></a>4.文件操作</h3><p><strong>rm a.txt    删除a.txt文件，删除需要用户确认，y/n</strong><br><strong>rm -f a.txt    不询问，直接删除a.txt文件</strong><br><strong>rm -r a    递归删除a文件夹（无论是否有内容）</strong><br><strong>rm -rf a    不询问递归删除a文件夹（慎用）</strong><br><strong>rm -rf *    删除当前目录下所有内容（最好别用）</strong><br><strong><em>rm -rf /\</em>    no 作 no die（Linux系统就玩完了）*</strong></p><p><strong>cp a.txt b.txt    将a.txt复制为b.txt文件</strong><br><strong>cp -r dir/ ../    将dir文件夹及子目录和文件复制到上一层目录中</strong></p><p><strong>mv a.txt ../    将a.txt文件移动到上一层目录中</strong><br><strong>mv a.txt b.txt    将a.txt文件重命名为b.txt</strong></p><p>touch a.txt    创建一个空的a.txt文件<br><strong>echo “good good study” &gt; a.txt    把”&gt;”左边的输出内容放到右边的文件里去，如果存在就覆盖，如果不存在就创建</strong><br><strong>vim a.txt    用文本编辑器编辑一个文件，如果不存在就创建</strong></p><h3 id="5-文件打包归档和压缩"><a href="#5-文件打包归档和压缩" class="headerlink" title="5.文件打包归档和压缩"></a>5.文件打包归档和压缩</h3><p>tar -cvf file.tar dirpath filepath    将dir文件夹和file文件在当前目录下打包成file.tar<br>tar –xvf file.tar    解包到当前目录</p><p>gzip file.tar    压缩文件或文件夹<br>gzip –d file.tar.gz    解压文件或文件夹</p><p><strong>tar -czvf file.tar.gz dirpath filepath    将dir文件夹和file文件在当前目录下打包并压缩成file.tar.gz</strong><br><strong>tar -xzvf file.tar.gz    解压并解包到当前目录下</strong><br><strong>tar -xzvf file.tar.gz -C /home/dijia478/    解压并解包到/home/dijia478/目录下</strong></p><p>常用参数：<br>-c：创建一个新tar文件<br>-v：显示运行过程的信息<br>-f：指定文件名<br>-z：调用gzip压缩命令进行压缩<br>-t：查看压缩文件的内容<br>-x：解开tar文件</p><p>zip test.txt.zip test.txt    也是打包并压缩<br>unzip test.txt.zip    解包并解包</p><p><strong>.rpm结尾的包，用rpm -ivh 命令安装</strong></p><h3 id="6-查看文本文件"><a href="#6-查看文本文件" class="headerlink" title="6.查看文本文件"></a>6.查看文本文件</h3><p><strong>cat a.txt    一次性显示整个文件内容</strong><br>more a.txt    可以分页看（翻页：空格,往回翻：b ，退出： q或者 Ctrl+C）<br><strong>less a.txt    不仅可以分页，还可以方便地搜索，回翻等操作（翻页：空格,往回翻：↑,往下翻:↓,退出：q或者 Ctrl+C）</strong></p><p>tail -10 a.txt    查看文件的尾部的10行<br><strong>tail -f user.log    实时刷新显示文件的尾部，这条命令对于观察调试程序的运行非常重要</strong></p><p>head -20 a.txt    查看文件的头部20行<br>注：ctrl+c 结束查看</p><h3 id="7-搜索查找命令"><a href="#7-搜索查找命令" class="headerlink" title="7.搜索查找命令"></a>7.搜索查找命令</h3><p><strong>grep ‘haha’ ./*    打印当前目录下所有文件中含有’haha’的地方（支持正则表达式）</strong><br>grep -c ‘haha’ ./*    显示匹配到的行数<br><strong>grep -r ‘haha’ ./*    对子目录也进行遍历搜索</strong><br>grep -l ‘haha’ ./*    只显示命中的文件名<br>grep -n ‘haha’ ./*    显示命中的行号<br>grep -ld skip ‘haha’ ./*     显示命中的文件名，不要搜索子目录</p><p>参数含义：<br>-r 递归搜索子目录<br>-l 只列出有匹配行的文件名<br>-n 列出匹配行的行号<br>-d skip 不搜索子文件夹</p><p>常用grep跟其他命令组合使用来查找我们关心的信息（管道）<br>示例：<br><strong>service –status-all | grep ‘httpd’    在当前系统所有服务中查找’httpd’</strong><br><strong>netstat -nltp | grep ‘22’    查找监听’22’端口的服务程序</strong><br><strong>ps –ef | grep java    查找系统中当前运行的java进程</strong></p><p><strong>find ./ -name ‘*.txt’    查找以.txt结尾的文件（会遍历当前目录）</strong><br><strong>find ./ -name ‘install*’    查找以install开头的文件或文件夹</strong><br>find ./ -type f    查找普通文件<br>find ./ -type l    查找连接文件(快捷方式)</p><h3 id="8-文本命令"><a href="#8-文本命令" class="headerlink" title="8.文本命令"></a>8.文本命令</h3><p>> 重定向输出，覆盖原有内容；<br>>&gt;    重定向输出，又追加功能；<br>cat /etc/passwd &gt; a.txt    将密码文件输出定向到a.txt中<br>cat /etc/passwd &gt;&gt; a.txt    输出并且追加<br>ifconfig &gt; ifconfig.txt    保存ip信息到文件中</p><p>wc -l a.txt    统计文本行数wc -w a.txt统计文本单词数wc -m a.txt统计文本字符数wc -c a.txt统计文本字节数</p><p><strong>vim编辑器，这里全都很常用</strong><br>vim filepath打开文件<br>按Esc键切换到命令行模式<br>切换到插入模式：<br>i在当前位置生前插入<br>I在当前行首插入<br>a在当前位置后插入<br>A在当前行尾插入<br>o在当前行之后插入一行<br>O在当前行之前插入一行<br>dd删除整行<br>7 dd向上删除7行<br>U回退(类似于windows 中 ctrl + z)<br>R替换<br>:（冒号）切换到底行模式<br>:q退出<br>:wq保存并退出（shift + zz也可以保存）<br>:q!不保存退出</p><h3 id="9-其他常用命令"><a href="#9-其他常用命令" class="headerlink" title="9.其他常用命令"></a>9.其他常用命令</h3><p><strong>echo $JAVA_HOME    输出变量JAVA_HOME的值</strong></p><p><strong>rpm -qa | grep tomcat    查看当前系统是否安装tomcat</strong><br><strong>rpm -e tomcat    卸载tomcat</strong><br>rpm 的其他附加命令<br>–force 强制操作 如强制安装删除等；<br>–requires 显示该包的依赖关系；<br><strong>–nodeps 忽略依赖关系并继续操作；</strong></p><p>whoami查询当前登陆的用户名<br>which ls查询ls命令的$PATH路径</p><p><strong>mkdir test &amp;&amp; cd test</strong><br>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。<br>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</p><h2 id="三、用户管理命令"><a href="#三、用户管理命令" class="headerlink" title="三、用户管理命令"></a>三、用户管理命令</h2><h3 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1.添加用户"></a>1.添加用户</h3><p>基本示例：<br>useradd user001</p><p>passwd 123456需要设置密码</p><p>参数手册：-u 指定组ID（uid）-g 指定所属的组名（gid）-G 指定多个组，用逗号“，”分开（Groups）-c 用户描述（comment）-d 指定用户目录-e 失效时间（expire date）</p><h3 id="2-删除用户"><a href="#2-删除用户" class="headerlink" title="2.删除用户"></a>2.删除用户</h3><p>userdel user002这样删除的时候，用户的主目录会被保留<br>userdel -r user002删除用户的同时删除用户的主目录</p><h3 id="3-修改用户属性"><a href="#3-修改用户属性" class="headerlink" title="3.修改用户属性"></a>3.修改用户属性</h3><p>指令：usermod<br>参数：<br>-l 修改用户名 （login）usermod -l a b（b改为a）<br>-g 修改组 usermod -g sys tom<br>-d 修改用户的宿主目录<br>-G 添加多个组 usermod -G sys,root tom<br>-L 锁定用户账号密码（Lock）<br>-U 解锁用户账号（Unlock）<br>示例：<br>usermod -l user002 user001将user001的登陆名改为user002<br>usermod -g root user002将user002的组改为root组<br>usermod -G hello1,hello2 user002给user002添加两个组hello1,hello2<br>usermod -d /home/dijia478 user002将user002的主目录改成/home/dijia478<br>（要事先创建dijia478目录，并且拷入环境变量文件）</p><h3 id="4-用户组管理"><a href="#4-用户组管理" class="headerlink" title="4.用户组管理"></a>4.用户组管理</h3><p>用户组相关属性：<br>每个用户至少属于一个用户组<br>（创建新用户时如果不指定所属组，则会自动创建并归属到一个跟用户名同名的组）<br>每个用户组可以包含多个用户<br>同一个用户组的用户享有该组共有的权限<br>用户组管理操作命令：<br>groupadd java创建用户组<br>groupdel hello2删除用户组<br>groupmod –n newname oldname修改用户组名称<br>groups user002查看用所属的组</p><h3 id="5-用户及用户组相关配置文件"><a href="#5-用户及用户组相关配置文件" class="headerlink" title="5.用户及用户组相关配置文件"></a>5.用户及用户组相关配置文件</h3><p>用户配置信息存放位置：<br>保存用户信息的文件：/etc/passwd<br>保存密码的文件：/etc/shadow</p><p>passwd文件示例：<br>user002:x:500:500:user002:/home/user002:/bin/bash<br>passwd文件各字段含义：<br>account:password:UID:GID:GECOS:directory:shell</p><p>shadow文件示例：<br>user002:$1$vRug41$UUxYzdP0i6s6wtUPieGDQ/:18617:0:99999:7:::<br>shadow文件各字段含义：</p><table><thead><tr><th>用户名</th><th>登陆系统的用户名</th></tr></thead><tbody><tr><td>密码</td><td>加密密码</td></tr><tr><td>最后一次修改时间</td><td>用户最后一次修改密码距现在的天数，从1970-1-1起</td></tr><tr><td>最小时间间隔</td><td>两次修改密码之间的最小天数</td></tr><tr><td>最大时间间隔</td><td>密码有效天数</td></tr><tr><td>警告时间</td><td>从系统警告到密码失效的天数</td></tr><tr><td>账号闲置时间</td><td>账号闲置时间</td></tr><tr><td>失效时间</td><td>密码失效的天数</td></tr><tr><td>标志</td><td>标志</td></tr></tbody></table><p>用户组配置信息存放位置：<br>保存用户组的文件：/etc/group<br>保存用户组密码的文件：/etc/gshadow（设置组管理员时才有用）</p><h3 id="6-其他的用户管理命令"><a href="#6-其他的用户管理命令" class="headerlink" title="6.其他的用户管理命令"></a>6.其他的用户管理命令</h3><p>id user002查看一个用户的UID和GIDsu user001切换到user001用户su - user001切换到user001用户，并且将环境也切换到user001用户的环境（推荐使用）exis退出当前shell（会退出当前登录用户）</p><h2 id="四、网络配置管理"><a href="#四、网络配置管理" class="headerlink" title="四、网络配置管理"></a>四、网络配置管理</h2><h3 id="1-网卡地址配置"><a href="#1-网卡地址配置" class="headerlink" title="1.网卡地址配置"></a>1.网卡地址配置</h3><p>检查网络连通性:<br><strong>ping 192.168.25.168    测试当前服务器和指定ip是否能进行网络通信</strong></p><p>查看ip地址<br><strong>ifconfig    查看所有网络设备的地址信息</strong><br>ifconfig eth0    查看指定的eth0以太网卡的地址信息</p><p>修改ip地址<br>ifconfig eth0 192.168.2.150 netmask 255.255.255.0</p><p>通过setup修改网络配置<br>在root权限下执行setup指令可以打开一个带菜单的伪图形界面来修改网络配置</p><p>通过配置文件修改ip地址<br>vi /etc/sysconfig/network-scripts/ifcfg-eth0 修改该配置文件即可改ip地址</p><h3 id="2-主机名配置管理"><a href="#2-主机名配置管理" class="headerlink" title="2.主机名配置管理"></a>2.主机名配置管理</h3><p>查看主机名<br>在shell提示符的@后有显示<br>或者用hostname指令打印出主机名</p><p>修改主机名<br>vi /etc/sysconfig/network    修改其中的hostname配置项:<br>HOSTNAME=newname<br>修改完成之后要重启服务器才能生效<br>要想立即生效，可以执行指令 hostname newname，然后注销重登陆</p><p>主机名-IP映射，服务器本地映射<br>服务器网络寻址时默认是现在本地的hosts文件中查找IP映射，通过修改hosts来映射局域网内部的主机名非常方便<br>实现方法，将局域网内的每一台主机的“hostnamip”写入每一台主机的hosts文件中：<br>vi /etc/hosts<br>192.168.2.150    user001-server-01<br>192.168.2.151    user001-server-02<br>192.168.2.152    user001-server-03</p><h3 id="3-网络服务启动与停止"><a href="#3-网络服务启动与停止" class="headerlink" title="3.网络服务启动与停止"></a>3.网络服务启动与停止</h3><p>列出系统所有应用服务状态：<br>service –status-all<br><strong>查看指定服务运行状态：</strong><br><strong>service servicename status</strong><br><strong>启动服务：</strong><br><strong>service servicename start</strong><br><strong>停止服务：</strong><br><strong>service servicename stop</strong></p><p><strong>列出所有服务的随机自起配置：</strong><br><strong>chkconfig –list</strong><br><strong>关闭服务的随机自起：</strong><br><strong>chkconfig servicename off</strong><br><strong>开启服务的随机自起：</strong><br><strong>chkconfig servicename on</strong></p><p>常用示例：<br><strong>重启网络服务：service network restart</strong><br><strong>停止httpd：service httpd stop</strong><br><strong>启动httpd：service httpd start</strong><br><strong>关闭防火墙服务：service iptables stop</strong><br><strong>关闭防火墙自动启动：chkconfig iptables off</strong></p><h3 id="4-查看网络连接信息"><a href="#4-查看网络连接信息" class="headerlink" title="4.查看网络连接信息"></a>4.查看网络连接信息</h3><p>指令：netstat<br>netstat常用示例：<br>netstat -natp<br><strong>netstat -nltp</strong><br>netstat -naup</p><p><strong>netstat -an | grep 3306    查询3306端口占用情况</strong></p><p>常用参数解释：<br>-a 显示所有连接和监听端口<br>-l 只显示监听进程<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化成数字。<br>-p 显示建立相关链接的程序名</p><p>lsof命令其实要比netstat强大<br>常用参数：<br>-i　显示所有连接<br>-i 6　仅获取IPv6流量<br>-iTCP 仅显示TCP连接<br>-i:8080　显示与8080端口相关的网络信息<br>-i@192.168.128.128　显示指定到192.168.128.128的连接<br>-i@192.168.128.128:22　显示基于主机与端口的连接<br>-i -sTCP:LISTEN　找出正等候连接的端口<br>-i -sTCP:ESTABLISHED　找出已建立的连接<br>-u 用户名　显示指定用户打开了什么<br>-u ^用户名 显示除指定用户以外的其它所有用户所做的事情<br>-p 10075 查看指定进程ID已打开的内容<br>其他用法：<br>kill -9 ‘lsof -t -u 用户名’    杀死指定用户所做的一切事情<br>lsof /var/log/messages/    显示与指定目录或文件交互的所有一切<br>lsof -u dijia478 -i @1.1.1.1    显示dijia478连接到1.1.1.1所做的一切</p><h2 id="五、常用系统管理命令"><a href="#五、常用系统管理命令" class="headerlink" title="五、常用系统管理命令"></a>五、常用系统管理命令</h2><h3 id="1-磁盘-内存使用信息查看"><a href="#1-磁盘-内存使用信息查看" class="headerlink" title="1.磁盘/内存使用信息查看"></a>1.磁盘/内存使用信息查看</h3><p><strong>df -h    查看磁盘空间状态信息</strong><br><strong>du -sh *    查看指定目录下所有子目录和文件的汇总大小</strong><br><strong>free    查看内存使用状况</strong></p><h3 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h3><p>top    查看实时刷新的系统进程信息<br>ps -ef    查看系统中当前瞬间的进程信息快照<br><strong>ps -ef | grep myshell    搜索myshell进程的信息</strong><br><strong>kill -9 pid    杀掉指定pid的进程（-9 表示强制杀死）</strong></p><h3 id="3-sudo权限的配置"><a href="#3-sudo权限的配置" class="headerlink" title="3.sudo权限的配置"></a>3.sudo权限的配置</h3><p>root用户因为具有不受限制的权限，使用不慎可能对系统造成不可估量的损害，因而，生产实际中，轻易不要使用su去切换到root的身份<br>如果普通用户需要使用一些系统级管理命令，可以使用sudo来执行，比如 sudo vim /etc/profile<br>给普通用户赋予sudo权限，配置方法如下：<br>例如，要给hadoop用户赋予sudo任何指令（或某条指定的命令）的权利，则编辑sudoers文件 vim /etc/sudoers<br>在其中加入需要赋予权限的用户<br>&gt;</p><blockquote><p>root        ALL=(ALL)    ALL<br>#让hadoop用户可以用root身份执行所有指令<br>hadoop    ALL=(ALL)    ALL<br>#让user002用户可以用root身份执行useradd,passwd命令<br>user002    ALL=(root)    /usr/sbin/useradd, /usr/bin/passwd</p></blockquote><p>检查是否生效:<br>[root@user001-server-01 user002]# sudo -lU user002<br>User user002 is not allowed to run sudo on user001-server-01.</p><h3 id="4-修改系统的默认启动级别"><a href="#4-修改系统的默认启动级别" class="headerlink" title="4.修改系统的默认启动级别"></a>4.修改系统的默认启动级别</h3><p>vim /etc/inittab</p><p>&gt;</p><blockquote><p>#   0 - halt (Do NOT set initdefault to this)<br>#   1 - Single user mode<br>#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)<br>#   3 - Full multiuser mode<br>#   4 - unused<br>#   5 - X11<br>#   6 - reboot (Do NOT set initdefault to this)<br>#<br>id:3:initdefault:<br>~</p></blockquote><p>用level 3 就启动全功能状态的命令行界面，5是图形界面。不要设置其他的，容易作死。<br>在命令行模式下，用startx可以手动启动图形界面(在服务器上操作)</p><h3 id="5-文件权限管理"><a href="#5-文件权限管理" class="headerlink" title="5.文件权限管理"></a>5.文件权限管理</h3><img src="/blog/2016/05/13/2016-05-13-Linux常用命令/linux02.png"><p>Linux三种文件类型：<br>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。<br>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。<br>设备文件： Linux系统把每一个设备都看成是一个文件<br>文件类型标识：<br>普通文件（-）<br>目录（d）<br>符号链接（l）<br>* 进入etc可以查看，相当于快捷方式<br>字符设备文件（c）<br>块设备文件（s）<br>套接字（s）<br>命名管道（p）</p><p>u 表示“用户（user）”，即文件或目录的所有者。<br>g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。<br>o 表示“其他（others）用户”。<br>a 表示“所有（all）用户”。它是系统默认值。<br>操作符号可以是：<br>+ 添加某个权限。<br>- 取消某个权限。<br>= 赋予给定权限并取消其他所有权限（如果有的话）。<br>设置mode所表示的权限可用下述字母的任意组合：<br>r 可读。<br>w 可写。<br>x 可执行。</p><p>文件权限管理：<br><strong>chmod u+rwx a.txt    为a.txt添加所属用户的rwx权限</strong><br>chmod 755 a.txt    为a.txt设置所属用户rwx权限，所属组rx权限，其他用户rx权限（r-4，w-2，x-1）<br>chmod u=rwx,g=rx,o=rx a.txt    （u代表所属用户 g代表所属组的成员用户 o代表其他用户）<br>chown user001:hello1 a.txt    将a.txt的所有者改成user001用户，所属组改成hello1组（需要root权限）<br>chown -R user001:hello1 dir    将dir文件夹的所有者改成user001用户，所属组改成hello1组（需要root权限）</p><h3 id="6-其他系统管理命令"><a href="#6-其他系统管理命令" class="headerlink" title="6.其他系统管理命令"></a>6.其他系统管理命令</h3><p>date “+%Y%m%d”按格式显示当前系统时间<br>date -s “2020-01-01 10:10:10”设置系统时间<br><strong>clear清屏幕(只是滚到上面看不到了)</strong><br>uname 显示系统信息<br>uname -a 显示本机详细信息。依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、系统目录结构&quot;&gt;&lt;a href=&quot;#一、系统目录结构&quot; class=&quot;headerlink&quot; title=&quot;一、系统目录结构&quot;&gt;&lt;/a&gt;一、系统目录结构&lt;/h2&gt;&lt;img src=&quot;/blog/2016/05/13/2016-05-13-Linux常用命令/linux01.png&quot;&gt;
&lt;p&gt;约定俗成：&lt;/p&gt;
&lt;p&gt;  bin (binaries)存放二进制可执行文件&lt;br&gt;  etc (etcetera)存放系统配置文件&lt;br&gt;  usr (unix shared resources)用于存放共享的系统资源&lt;br&gt;  home 存放用户文件的根目录&lt;br&gt;  root 超级用户目录&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://dijia478.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://dijia478.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存泄漏及性能调优</title>
    <link href="http://dijia478.cn//blog/2016/03/27/2016-03-27-JVM%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://dijia478.cn//blog/2016/03/27/2016-03-27-JVM内存泄漏及性能调优/</id>
    <published>2016-03-27T07:46:52.000Z</published>
    <updated>2018-01-03T08:27:17.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JVM内存模型及垃圾收集算法"><a href="#一、JVM内存模型及垃圾收集算法" class="headerlink" title="一、JVM内存模型及垃圾收集算法"></a>一、JVM内存模型及垃圾收集算法</h2><h3 id="1-根据Java虚拟机规范，JVM将内存划分为："><a href="#1-根据Java虚拟机规范，JVM将内存划分为：" class="headerlink" title="1.根据Java虚拟机规范，JVM将内存划分为："></a>1.根据Java虚拟机规范，JVM将内存划分为：</h3><ul><li>New（年轻代）</li><li>Tenured（年老代）</li><li>永久代（Perm）</li></ul><p>其中New和Tenured属于堆内存，堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配，Perm不属于堆内存，有虚拟机直接分配，但可以通过<strong>-XX:PermSize -XX:MaxPermSize</strong> 等参数调整其大小。</p><a id="more"></a><h4 id="年轻代（New）："><a href="#年轻代（New）：" class="headerlink" title="年轻代（New）："></a>年轻代（New）：</h4><p>绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会很快变得不可到达，所以很多对象被创建在新生代，然后消失。对象从这个区域消失的过程我们称之为minor GC。新生代是用来保存那些第一次被创建的对象，他可以被分为三个空间:</p><ul><li>一个伊甸园空间（Eden ）</li><li>两个幸存者空间（Survivor ）</li></ul><p>绝大多数刚刚被创建的对象会存放在伊甸园空间（Eden）。在伊甸园空间执行了第一次GC之后，存活的对象被移动到其中一个幸存者空间。此后，在伊甸园空间执行GC之后，存活的对象会被堆积在同一个幸存者空间。当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。之后会清空已经饱和的那个幸存者空间。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。在以上的步骤中重复几次依然存活的对象，就会被移动到老年代。<br>如果你仔细观察这些步骤就会发现，其中一个幸存者空间必须保持是空的。如果两个幸存者空间都有数据，或者两个空间都是空的，那一定标志着你的系统出现了某种错误。</p><h4 id="年老代（Tenured-："><a href="#年老代（Tenured-：" class="headerlink" title="年老代（Tenured)："></a>年老代（Tenured)：</h4><p>对象没有变得不可达，并且从新生代中存活下来，会被拷贝到这里。其所占用的空间要比新生代多。也正由于其相对较大的空间，发生在老年代上的GC要比新生代少得多。对象从老年代中消失的过程，我们称之为major GC（或者full GC）。老年代空间的GC事件基本上是在空间已满时发生，执行的过程根据GC类型不同而不同，JDK7一共有5种GC类型：</p><ul><li>Serial GC</li><li>Parallel GC</li><li>Parallel Old GC (Parallel Compacting GC)</li><li>Concurrent Mark &amp; Sweep GC  (or “CMS”)</li><li>Garbage First (G1) GC</li></ul><h4 id="永久代（Perm）："><a href="#永久代（Perm）：" class="headerlink" title="永久代（Perm）："></a>永久代（Perm）：</h4><p>也被称为方法区（method area）。用来保存类常量以及字符串常量、Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间。因此，这个区域不是用来永久的存储那些从老年代存活下来的对象。这个区域也可能发生GC。并且发生在这个区域上的GC事件也会被算为major GC。</p><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><p>垃圾回收算法可以分为三类，都基于标记-清除（复制）算法：</p><ul><li>Serial算法（单线程）</li><li>并行算法</li><li>并发算法</li></ul><p>JVM会根据机器的硬件配置对每个内存代选择适合的回收算法，比如，如果机器多于1个核，会对年轻代选择并行算法，关于选择细节请参考JVM调优文档。</p><p>稍微解释下的是，并行算法是用多线程进行垃圾回收，回收期间会暂停程序的执行，而并发算法，也是多线程回收，但期间不停止应用执行。所以，并发算法适用于交互性高的一些程序。经过观察，并发算法会减少年轻代的大小，其实就是使用了一个大的年老代，这反过来跟并行算法相比吞吐量相对较低。</p><p>还有一个问题是，垃圾回收动作何时执行？</p><ul><li>当年轻代内存满时，会引发一次普通GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC</li><li>当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代</li><li>当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载</li></ul><p>另一个问题是，何时会抛出OutOfMemoryException，并不是内存被耗空的时候才抛出</p><ul><li>JVM98%的时间都花费在内存回收</li><li>每次回收的内存小于2%</li></ul><p>满足这两个条件将触发OutOfMemoryException，这将会留给系统一个微小的间隙以做一些Down之前的操作，比如手动打印Heap Dump。</p><h2 id="二、内存泄漏及解决方法"><a href="#二、内存泄漏及解决方法" class="headerlink" title="二、内存泄漏及解决方法"></a>二、内存泄漏及解决方法</h2><h3 id="1-系统崩溃前的一些现象："><a href="#1-系统崩溃前的一些现象：" class="headerlink" title="1.系统崩溃前的一些现象："></a>1.系统崩溃前的一些现象：</h3><ul><li>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</li><li>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</li><li>年老代的内存越来越大并且每次FullGC后年老代没有内存被释放</li></ul><p>之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。</p><h3 id="2-生成堆的dump文件"><a href="#2-生成堆的dump文件" class="headerlink" title="2.生成堆的dump文件"></a>2.生成堆的dump文件</h3><p>通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。</p><h3 id="3-分析dump文件"><a href="#3-分析dump文件" class="headerlink" title="3.分析dump文件"></a>3.分析dump文件</h3><p>下面要考虑的是如何打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：</p><ul><li>Visual VM</li><li>IBM HeapAnalyzer</li><li>JDK 自带的Hprof工具</li></ul><p>使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。因此，我们又选用了Eclipse专门的静态内存分析工具：Mat。</p><h3 id="4-分析内存泄漏"><a href="#4-分析内存泄漏" class="headerlink" title="4.分析内存泄漏"></a>4.分析内存泄漏</h3><p>通过Mat我们能清楚地看到，哪些对象被怀疑为内存泄漏，哪些对象占的空间最大及对象的调用关系。针对本案，在ThreadLocal中有很多的JbpmContext实例，经过调查是JBPM的Context没有关闭所致。另外，通过Mat或JMX我们还可以分析线程状态，可以观察到线程被阻塞在哪个对象上，从而判断系统的瓶颈。</p><h3 id="5-回归问题"><a href="#5-回归问题" class="headerlink" title="5.回归问题"></a>5.回归问题</h3><p>Q：为什么崩溃前垃圾回收的时间越来越长？<br>A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定时间是不变的，变的是复制部分，因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，垃圾回收的时间也可以作为判断内存泄漏的依据</p><p>Q：为什么Full GC的次数越来越多？<br>A：因此内存的积累，逐渐耗尽了年老代的内存，导致新对象分配没有更多的空间，从而导致频繁的垃圾回收</p><p>Q:为什么年老代占用的内存越来越大？<br>A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代</p><h2 id="三、性能调优"><a href="#三、性能调优" class="headerlink" title="三、性能调优"></a>三、性能调优</h2><p>除了上述内存泄漏外，我们还发现CPU长期不足3%，系统吞吐量不够，针对8core×16G、64bit的Linux服务器来说，是严重的资源浪费。</p><p>在CPU负载不足的同时，偶尔会有用户反映请求的时间过长，我们意识到必须对程序及JVM进行调优。从以下几个方面进行：</p><ul><li>线程池：解决用户响应时间长的问题</li><li>连接池</li><li>JVM启动参数：调整各代的内存比例和垃圾回收算法，提高吞吐量</li><li>程序算法：改进程序逻辑算法提高性能（这里不做讲解）</li></ul><h3 id="1-Java线程池（java-util-concurrent-ThreadPoolExecutor）"><a href="#1-Java线程池（java-util-concurrent-ThreadPoolExecutor）" class="headerlink" title="1.Java线程池（java.util.concurrent.ThreadPoolExecutor）"></a>1.Java线程池（java.util.concurrent.ThreadPoolExecutor）</h3><p>大多数JVM6上的应用采用的线程池都是JDK自带的线程池，之所以把成熟的Java线程池进行罗嗦说明，是因为该线程池的行为与我们想象的有点出入。Java线程池有几个重要的配置参数：</p><ul><li>corePoolSize：核心线程数（最新线程数）</li><li>maximumPoolSize：最大线程数，超过这个数量的任务会被拒绝，用户可以通过RejectedExecutionHandler接口自定义处理方式</li><li>keepAliveTime：线程保持活动的时间</li><li>workQueue：工作队列，存放执行的任务</li></ul><p>Java线程池需要传入一个Queue参数（workQueue）用来存放执行的任务，而对Queue的不同选择，线程池有完全不同的行为：</p><ul><li><code>SynchronousQueue：``一个无容量的等待队列，一个线程的insert操作必须等待另一线程的remove操作，采用这个Queue线程池将会为每个任务分配一个新线程</code></li><li><code>LinkedBlockingQueue ：</code> <code>无界队列，采用该Queue，线程池将忽略</code> maximumPoolSize参数，仅用corePoolSize的线程处理所有的任务，未处理的任务便在<code>LinkedBlockingQueue中排队</code></li><li><code>ArrayBlockingQueue： 有界队列，在有界队列和</code> maximumPoolSize的作用下，程序将很难被调优：更大的Queue和小的maximumPoolSize将导致CPU的低负载；小的Queue和大的池，Queue就没起动应有的作用。</li></ul><p>其实我们的要求很简单，希望线程池能跟连接池一样，能设置最小线程数、最大线程数，当最小数&lt;任务&lt;最大数时，应该分配新的线程处理；当任务&gt;最大数时，应该等待有空闲线程再处理该任务。</p><p>但线程池的设计思路是，任务应该放到Queue中，当Queue放不下时再考虑用新线程处理，如果Queue满且无法派生新线程，就拒绝该任务。设计导致“先放等执行”、“放不下再执行”、“拒绝不等待”。所以，根据不同的Queue参数，要提高吞吐量不能一味地增大maximumPoolSize。</p><p>当然，要达到我们的目标，必须对线程池进行一定的封装，幸运的是ThreadPoolExecutor中留了足够的自定义接口以帮助我们达到目标。我们封装的方式是：</p><ul><li>以SynchronousQueue作为参数，使maximumPoolSize发挥作用，以防止线程被无限制的分配，同时可以通过提高maximumPoolSize来提高系统吞吐量</li><li>自定义一个RejectedExecutionHandler，当线程数超过maximumPoolSize时进行处理，处理方式为隔一段时间检查线程池是否可以执行新Task，如果可以把拒绝的Task重新放入到线程池，检查的时间依赖keepAliveTime的大小。</li></ul><h3 id="2-连接池（org-apache-commons-dbcp-BasicDataSource）"><a href="#2-连接池（org-apache-commons-dbcp-BasicDataSource）" class="headerlink" title="2.连接池（org.apache.commons.dbcp.BasicDataSource）"></a>2.连接池（org.apache.commons.dbcp.BasicDataSource）</h3><p>在使用org.apache.commons.dbcp.BasicDataSource的时候，因为之前采用了默认配置，所以当访问量大时，通过JMX观察到很多Tomcat线程都阻塞在BasicDataSource使用的Apache ObjectPool的锁上，直接原因当时是因为BasicDataSource连接池的最大连接数设置的太小，默认的BasicDataSource配置，仅使用8个最大连接。</p><p>我还观察到一个问题，当较长的时间不访问系统，比如2天，DB上的Mysql会断掉所以的连接，导致连接池中缓存的连接不能用。为了解决这些问题，我们充分研究了BasicDataSource，发现了一些优化的点：</p><ul><li>Mysql默认支持100个链接，所以每个连接池的配置要根据集群中的机器数进行，如有2台服务器，可每个设置为60</li><li>initialSize：参数是一直打开的连接数</li><li>minEvictableIdleTimeMillis：该参数设置每个连接的空闲时间，超过这个时间连接将被关闭</li><li>timeBetweenEvictionRunsMillis：后台线程的运行周期，用来检测过期连接</li><li>maxActive：最大能分配的连接数</li><li>maxIdle：最大空闲数，当连接使用完毕后发现连接数大于maxIdle，连接将被直接关闭。只有initialSize &lt; x &lt; maxIdle的连接将被定期检测是否超期。这个参数主要用来在峰值访问时提高吞吐量。</li><li>initialSize是如何保持的？经过研究代码发现，BasicDataSource会关闭所有超期的连接，然后再打开initialSize数量的连接，这个特性与minEvictableIdleTimeMillis、timeBetweenEvictionRunsMillis一起保证了所有超期的initialSize连接都会被重新连接，从而避免了Mysql长时间无动作会断掉连接的问题。</li></ul><h3 id="3-JVM参数"><a href="#3-JVM参数" class="headerlink" title="3.JVM参数"></a>3.JVM参数</h3><p>在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置，默认情况不做任何设置JVM会工作的很好，但对一些配置很好的Server和具体的应用必须仔细调优才能获得最佳性能。通过设置我们希望达到一些目标：</p><ul><li>GC的时间足够的小</li><li>GC的次数足够的少</li><li>发生Full GC的周期足够的长</li></ul><p>前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其平衡。</p><p>（1）针对JVM堆的设置一般，可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值</p><p>（2）年轻代和年老代将根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小</p><p>（3）年轻代和年老代设置多大才算合理？这个我问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响：</p><ul><li>更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC</li><li>更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率</li><li>如何选择应该依赖应用程序对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 （B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间</li></ul><p>（4）在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： <strong>-XX:+UseParallelOldGC</strong> ，默认为Serial收集</p><p>（5）线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p><p>（6）可以通过下面的参数打Heap Dump信息：</p><ul><li>-XX:HeapDumpPath</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:/usr/aaa/dump/heap_trace.txt</li></ul><p>通过下面参数可以控制OutOfMemoryError时打印堆的信息</p><ul><li>-XX:+HeapDumpOnOutOfMemoryError</li></ul><p>请看一下一个时间的Java参数配置：（服务器：Linux 64Bit，8Core×16G）</p><p><strong>JAVA_OPTS=”$JAVA_OPTS -server -Xms3G -Xmx3G -Xss256k -XX:PermSize=128m -XX:MaxPermSize=128m -XX:+UseParallelOldGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/aaa/dump -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/usr/aaa/dump/heap_trace.txt -XX:NewSize=1G -XX:MaxNewSize=1G”</strong></p><p>经过观察该配置非常稳定，每次普通GC的时间在10ms左右，Full GC基本不发生，或隔很长很长的时间才发生一次</p><p>通过分析dump文件可以发现，每个1小时都会发生一次Full GC，经过多方求证，只要在JVM中开启了JMX服务，JMX将会1小时执行一次Full GC以清除引用，关于这点请参考<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、JVM内存模型及垃圾收集算法&quot;&gt;&lt;a href=&quot;#一、JVM内存模型及垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;一、JVM内存模型及垃圾收集算法&quot;&gt;&lt;/a&gt;一、JVM内存模型及垃圾收集算法&lt;/h2&gt;&lt;h3 id=&quot;1-根据Java虚拟机规范，JVM将内存划分为：&quot;&gt;&lt;a href=&quot;#1-根据Java虚拟机规范，JVM将内存划分为：&quot; class=&quot;headerlink&quot; title=&quot;1.根据Java虚拟机规范，JVM将内存划分为：&quot;&gt;&lt;/a&gt;1.根据Java虚拟机规范，JVM将内存划分为：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;New（年轻代）&lt;/li&gt;
&lt;li&gt;Tenured（年老代）&lt;/li&gt;
&lt;li&gt;永久代（Perm）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中New和Tenured属于堆内存，堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配，Perm不属于堆内存，有虚拟机直接分配，但可以通过&lt;strong&gt;-XX:PermSize -XX:MaxPermSize&lt;/strong&gt; 等参数调整其大小。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://dijia478.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程相关问题汇总</title>
    <link href="http://dijia478.cn//blog/2015/12/23/2015-12-23-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://dijia478.cn//blog/2015/12/23/2015-12-23-Java多线程相关问题汇总/</id>
    <published>2015-12-23T02:18:18.000Z</published>
    <updated>2018-01-03T05:17:35.299Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><blockquote><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。</p></blockquote><a id="more"></a><h4 id="多线程有什么用？"><a href="#多线程有什么用？" class="headerlink" title="多线程有什么用？"></a>多线程有什么用？</h4><blockquote><ul><li><p>发挥多核CPU的优势<br>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p></li><li><p>防止阻塞<br>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p></li><li><p>便于建模<br>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p></li></ul><p>使用多线程的优势：<br>更多的处理器核心；更快的响应时间；更好的编程模型。</p></blockquote><h4 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h4><blockquote><p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p></blockquote><h4 id="如何在Java中实现多线程？"><a href="#如何在Java中实现多线程？" class="headerlink" title="如何在Java中实现多线程？"></a>如何在Java中实现多线程？</h4><blockquote><p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程，但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类，或者直接实现Runnable接口来重写run方法实现线程。至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p></blockquote><h4 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h4><blockquote><p>这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。</p></blockquote><h4 id="Thread-类中的start和-run方法有什么区别？"><a href="#Thread-类中的start和-run方法有什么区别？" class="headerlink" title="Thread 类中的start和 run方法有什么区别？"></a>Thread 类中的start和 run方法有什么区别？</h4><blockquote><p>start方法被用来启动新创建的线程，只有调用了start方法，才会表现出多线程的特性，而且start内部调用了run方法，不同线程的run方法里面的代码交替执行，这和直接调用run方法的效果不一样。</p><p>当你调用run方法的时候，只会是在原来的线程中调用，没有新的线程启动，start方法才会启动新线程。如果只是调用run方法，那么代码还是同步执行的，必须等待一个线程的run方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run方法里面的代码。</p></blockquote><h4 id="Java中Runnable和Callable有什么不同？"><a href="#Java中Runnable和Callable有什么不同？" class="headerlink" title="Java中Runnable和Callable有什么不同？"></a>Java中Runnable和Callable有什么不同？</h4><blockquote><p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call方法可以返回值（是一个泛型）和抛出异常，返回装载有计算结果的Future对象。和Future、FutureTask配合可以用来获取多线程执行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。而Runnable接口中的run方法的返回值是void，它做的事情只是纯粹地去执行run方法中的代码而已。</p></blockquote><h4 id="Java中CyclicBarrier-和-CountDownLatch有什么不同？"><a href="#Java中CyclicBarrier-和-CountDownLatch有什么不同？" class="headerlink" title="Java中CyclicBarrier 和 CountDownLatch有什么不同？"></a>Java中CyclicBarrier 和 CountDownLatch有什么不同？</h4><blockquote><p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。</p><p>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务<br>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p></blockquote><h4 id="Java中如何停止一个线程？"><a href="#Java中如何停止一个线程？" class="headerlink" title="Java中如何停止一个线程？"></a>Java中如何停止一个线程？</h4><blockquote><p>Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop, suspend和 resume的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run或者 call方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run方法的循环或者是取消任务来中断线程。</p></blockquote><h4 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h4><blockquote><p>简单的说，如果异常没有被捕获，该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException方法进行处理。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。</p></blockquote><h4 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h4><blockquote><p>你可以通过共享对象来实现这个目的，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待.或者是使用像阻塞队列这样并发的数据结构，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p></blockquote><h4 id="什么是线程安全？Vector是一个线程安全类吗？"><a href="#什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="什么是线程安全？Vector是一个线程安全类吗？"></a>什么是线程安全？Vector是一个线程安全类吗？</h4><blockquote><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。简单来说就是，如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><ul><li><p>不可变<br>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p></li><li><p>绝对线程安全<br>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p></li><li><p>相对线程安全<br>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p></li><li><p>线程非安全<br>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p></li></ul></blockquote><h4 id="如何强制启动一个线程？"><a href="#如何强制启动一个线程？" class="headerlink" title="如何强制启动一个线程？"></a>如何强制启动一个线程？</h4><blockquote><p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p></blockquote><h4 id="Java多线程中调用wait和-sleep方法有什么不同？"><a href="#Java多线程中调用wait和-sleep方法有什么不同？" class="headerlink" title="Java多线程中调用wait和 sleep方法有什么不同？"></a>Java多线程中调用wait和 sleep方法有什么不同？</h4><blockquote><p>Java程序中wait和sleep都可以用来放弃CPU一定的时间，都会造成某种形式的暂停。<br>wait方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁。<br>而sleep方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。<br>如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器。</p></blockquote><h4 id="Thread-sleep-0-的作用是什么？"><a href="#Thread-sleep-0-的作用是什么？" class="headerlink" title="Thread.sleep(0)的作用是什么？"></a>Thread.sleep(0)的作用是什么？</h4><blockquote><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p></blockquote><h4 id="怎么唤醒一个阻塞的线程？"><a href="#怎么唤醒一个阻塞的线程？" class="headerlink" title="怎么唤醒一个阻塞的线程？"></a>怎么唤醒一个阻塞的线程？</h4><blockquote><p>如果线程是因为调用了wait、sleep或者join方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p></blockquote><h4 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h4><blockquote><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p></blockquote><h4 id="什么是线程池？-为什么要使用它？"><a href="#什么是线程池？-为什么要使用它？" class="headerlink" title="什么是线程池？ 为什么要使用它？"></a>什么是线程池？ 为什么要使用它？</h4><blockquote><p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p></blockquote><h4 id="如果你提交任务时，线程池队列已满，这时会发生什么？"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么？"></a>如果你提交任务时，线程池队列已满，这时会发生什么？</h4><blockquote><p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit方法将会抛出一个RejectedExecutionException异常。如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p></blockquote><h4 id="Java线程池中submit和-execute方法有什么区别？"><a href="#Java线程池中submit和-execute方法有什么区别？" class="headerlink" title="Java线程池中submit和 execute方法有什么区别？"></a>Java线程池中submit和 execute方法有什么区别？</h4><blockquote><p>两个方法都可以向线程池提交任务，execute方法的返回类型是void，它定义在Executor接口中, 而submit方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p></blockquote><h4 id="Java中用到的线程调度算法是什么？"><a href="#Java中用到的线程调度算法是什么？" class="headerlink" title="Java中用到的线程调度算法是什么？"></a>Java中用到的线程调度算法是什么？</h4><blockquote><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p></blockquote><h4 id="Java内存模型是什么？"><a href="#Java内存模型是什么？" class="headerlink" title="Java内存模型是什么？"></a>Java内存模型是什么？</h4><blockquote><p>Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它定义了一种多线程访问Java内存的规范，在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。我简单总结一下Java内存模型的几部分内容：</p><ul><li>Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</li><li>定义了几个原子操作，用于操作主内存和工作内存中的变量</li><li>定义了volatile变量的使用规则</li><li>happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</li></ul><p>我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p></blockquote><h4 id="Java中的volatile-变量是什么？"><a href="#Java中的volatile-变量是什么？" class="headerlink" title="Java中的volatile 变量是什么？"></a>Java中的volatile 变量是什么？</h4><blockquote><p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。volatile关键字的作用主要有两个：</p><p>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据<br>代码底层执行不像我们看到的高级语言—Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率<br>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p></blockquote><h4 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h4><blockquote><p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p></blockquote><h4 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的?"></a>线程类的构造方法、静态块是被哪个线程调用的?</h4><blockquote><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。<br>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><ul><li>Thread2的构造方法、静态块是main线程调用的，Thread2的run方法是Thread2自己调用的</li><li>Thread1的构造方法、静态块是Thread2调用的，Thread1的run方法是Thread1自己调用的</li></ul></blockquote><h4 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h4><blockquote><p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。</p></blockquote><h4 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h4><blockquote><ul><li>乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</li><li>悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</li></ul></blockquote><h4 id="什么是自旋？"><a href="#什么是自旋？" class="headerlink" title="什么是自旋？"></a>什么是自旋？</h4><blockquote><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p></blockquote><h4 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h4><blockquote><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p></blockquote><h4 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h4><blockquote><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。<br>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。<br>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p></blockquote><h4 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h4><blockquote><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p></blockquote><h4 id="什么是FutureTask？"><a href="#什么是FutureTask？" class="headerlink" title="什么是FutureTask？"></a>什么是FutureTask？</h4><blockquote><p>在Java并发程序中FutureTask表示一个可以取消的异步运算任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务进行启动和取消运算、查询运算是否完成和取回运算结果等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是实现了Runnable接口所以它可以提交给Executor线程池来执行。</p></blockquote><h4 id="不可变对象对多线程有什么帮助？"><a href="#不可变对象对多线程有什么帮助？" class="headerlink" title="不可变对象对多线程有什么帮助？"></a>不可变对象对多线程有什么帮助？</h4><blockquote><p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p></blockquote><h4 id="Java中什么是竞态条件？-举个例子说明。"><a href="#Java中什么是竞态条件？-举个例子说明。" class="headerlink" title="Java中什么是竞态条件？ 举个例子说明。"></a>Java中什么是竞态条件？ 举个例子说明。</h4><blockquote><p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理。</p></blockquote><h4 id="Java中notify-和-notifyAll有什么区别？"><a href="#Java中notify-和-notifyAll有什么区别？" class="headerlink" title="Java中notify 和 notifyAll有什么区别？"></a>Java中notify 和 notifyAll有什么区别？</h4><blockquote><p>这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p></blockquote><h4 id="为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><blockquote><p>这是个设计相关的问题，它考察的是程序员对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait方法就有意义了。如果wait方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p></blockquote><h4 id="wait-notify-notifyAll用法？"><a href="#wait-notify-notifyAll用法？" class="headerlink" title="wait, notify, notifyAll用法？"></a>wait, notify, notifyAll用法？</h4><blockquote><p>只能在同步方法或者同步块中使用wait()方法。在执行wait()方法后，当前线程释放锁（这点与sleep和yield方法不同）。调用了wait函数的线程会一直等待，知道有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立刻获得对象的锁，要等待执行notify()方法的线程执行完，即退出synchronized代码块后，当前线程才会释放锁，而呈wait状态的线程才可以获取该对象锁。<br>如果调用wait()方法时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕获异常。<br>notify方法只会（随机）唤醒一个正在等待的线程，而notifyAll方法会唤醒所有正在等待的线程。如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。<br>带参数的wait(long timeout)或者wait(long timeout, int nanos)方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。<br>注意，wait方法和notify/notifyAll方法要在同步块中调用，主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p></blockquote><h4 id="wait方法和notify-notifyAll方法在放弃对象监视器时有什么区别？"><a href="#wait方法和notify-notifyAll方法在放弃对象监视器时有什么区别？" class="headerlink" title="wait方法和notify/notifyAll方法在放弃对象监视器时有什么区别？"></a>wait方法和notify/notifyAll方法在放弃对象监视器时有什么区别？</h4><blockquote><p>wait方法立即释放对象监视器，notify/notifyAll方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p></blockquote><h4 id="多线程中的忙循环是什么"><a href="#多线程中的忙循环是什么" class="headerlink" title="多线程中的忙循环是什么?"></a>多线程中的忙循环是什么?</h4><blockquote><p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait, sleep或 yield它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p></blockquote><h4 id="怎么检测一个线程是否持有对象监视器？"><a href="#怎么检测一个线程是否持有对象监视器？" class="headerlink" title="怎么检测一个线程是否持有对象监视器？"></a>怎么检测一个线程是否持有对象监视器？</h4><blockquote><p>我也是在网上看到一篇文章才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj.方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。</p></blockquote><h4 id="Java中interrupted-和-isInterruptedd方法的区别？"><a href="#Java中interrupted-和-isInterruptedd方法的区别？" class="headerlink" title="Java中interrupted 和 isInterruptedd方法的区别？"></a>Java中interrupted 和 isInterruptedd方法的区别？</h4><blockquote><p>interrupted和 isInterrupted的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p></blockquote><h4 id="为什么你应该在循环中检查等待条件"><a href="#为什么你应该在循环中检查等待条件" class="headerlink" title="为什么你应该在循环中检查等待条件?"></a>为什么你应该在循环中检查等待条件?</h4><blockquote><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p></blockquote><h4 id="Java中的同步集合与并发集合有什么区别？"><a href="#Java中的同步集合与并发集合有什么区别？" class="headerlink" title="Java中的同步集合与并发集合有什么区别？"></a>Java中的同步集合与并发集合有什么区别？</h4><blockquote><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p></blockquote><h4 id="Java中ConcurrentHashMap的并发度是什么？"><a href="#Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="Java中ConcurrentHashMap的并发度是什么？"></a>Java中ConcurrentHashMap的并发度是什么？</h4><blockquote><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数segment的大小，默认值为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这样在多线程情况下也能避免争用。这也是ConcurrentHashMap对Hashtable的最大优势，Hashtable不能同时有两条线程获取Hashtable中的数据。</p></blockquote><h4 id="Java中堆和栈有什么不同？"><a href="#Java中堆和栈有什么不同？" class="headerlink" title="Java中堆和栈有什么不同？"></a>Java中堆和栈有什么不同？</h4><blockquote><p>为什么把这个问题归类在多线程和并发里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p></blockquote><h4 id="生产者消费者模型的作用是什么？"><a href="#生产者消费者模型的作用是什么？" class="headerlink" title="生产者消费者模型的作用是什么？"></a>生产者消费者模型的作用是什么？</h4><blockquote><p>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p></blockquote><h4 id="如何写代码来解决生产者消费者问题？"><a href="#如何写代码来解决生产者消费者问题？" class="headerlink" title="如何写代码来解决生产者消费者问题？"></a>如何写代码来解决生产者消费者问题？</h4><blockquote><p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型。</p></blockquote><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><blockquote><p>Java多线程中的死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul></blockquote><h4 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h4><blockquote><ul><li>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁</li><li>让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实</li><li>设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量</li><li>既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后变回返回一个失败信息</li></ul></blockquote><h4 id="Java中活锁和死锁有什么区别？"><a href="#Java中活锁和死锁有什么区别？" class="headerlink" title="Java中活锁和死锁有什么区别？"></a>Java中活锁和死锁有什么区别？</h4><blockquote><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p></blockquote><h4 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h4><blockquote><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我看到一本书上写到。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p></blockquote><h4 id="你如何在Java中获取线程堆栈？"><a href="#你如何在Java中获取线程堆栈？" class="headerlink" title="你如何在Java中获取线程堆栈？"></a>你如何在Java中获取线程堆栈？</h4><blockquote><p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p></blockquote><h4 id="JVM中哪个参数是用来控制线程的栈堆栈小的？"><a href="#JVM中哪个参数是用来控制线程的栈堆栈小的？" class="headerlink" title="JVM中哪个参数是用来控制线程的栈堆栈小的？"></a>JVM中哪个参数是用来控制线程的栈堆栈小的？</h4><blockquote><p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。</p></blockquote><h4 id="Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="Java中synchronized 和 ReentrantLock 有什么不同？"></a>Java中synchronized 和 ReentrantLock 有什么不同？</h4><blockquote><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点，比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。ReentrantLock 类实现了 Lock接口，提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量扩展性。</p><p>ReentrantLock比synchronized的扩展性体现在几点上：</p><ul><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。<br>从性能上来说ReentrantLock比synchronized略有胜出（JDK6起），在JDK5中是远远胜出，为嘛不放弃synchronized呢？ReentrantLock的危险性要比同步机制高，如果忘记在finnally块中调用unlock，那么虽然代码表面上能正常运行，但实际上已经埋下了一颗定时炸弹，并很可能伤及其他代码。仅当内置锁不能满足需求时，才可以考虑使用ReentrantLock.</li></ul></blockquote><h4 id="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h4><blockquote><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1.，这样T1就会先完成而T3最后完成。</p></blockquote><h4 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h4><blockquote><p>可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但放弃时间不确定，有可能刚刚放弃，马上又获得CPU时间片。这里需要注意的是yield()方法和sleep方法一样，线程并不会让出锁，和wait不同。</p></blockquote><h4 id="Java中Semaphore是什么？"><a href="#Java中Semaphore是什么？" class="headerlink" title="Java中Semaphore是什么？"></a>Java中Semaphore是什么？</h4><blockquote><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p></blockquote><h4 id="Semaphore有什么作用？"><a href="#Semaphore有什么作用？" class="headerlink" title="Semaphore有什么作用？"></a>Semaphore有什么作用？</h4><blockquote><p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p></blockquote><h4 id="Swing是线程安全的吗？-为什么？"><a href="#Swing是线程安全的吗？-为什么？" class="headerlink" title="Swing是线程安全的吗？ 为什么？"></a>Swing是线程安全的吗？ 为什么？</h4><blockquote><p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。</p></blockquote><h4 id="Swing-API中那些方法是线程安全的？"><a href="#Swing-API中那些方法是线程安全的？" class="headerlink" title="Swing API中那些方法是线程安全的？"></a>Swing API中那些方法是线程安全的？</h4><blockquote><p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p></blockquote><h4 id="Java中invokeAndWait-和-invokeLater有什么区别？"><a href="#Java中invokeAndWait-和-invokeLater有什么区别？" class="headerlink" title="Java中invokeAndWait 和 invokeLater有什么区别？"></a>Java中invokeAndWait 和 invokeLater有什么区别？</h4><blockquote><p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。</p></blockquote><h4 id="如何在Java中创建Immutable对象？"><a href="#如何在Java中创建Immutable对象？" class="headerlink" title="如何在Java中创建Immutable对象？"></a>如何在Java中创建Immutable对象？</h4><blockquote><p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p></blockquote><h4 id="Java中的ReadWriteLock是什么？"><a href="#Java中的ReadWriteLock是什么？" class="headerlink" title="Java中的ReadWriteLock是什么？"></a>Java中的ReadWriteLock是什么？</h4><blockquote><p>ReadWriteLock是Java 5 中新增的一个接口，一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p></blockquote><h4 id="单例模式的双检锁是什么？"><a href="#单例模式的双检锁是什么？" class="headerlink" title="单例模式的双检锁是什么？"></a>单例模式的双检锁是什么？</h4><blockquote><p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。可以参考我的这篇文章：</p><p><a href="http://dijia478.cn/blog/2015/04/18/2015-04-18-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%86%99%E5%87%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">如何正确的写出单例模式</a></p></blockquote><h4 id="如何在Java中创建线程安全的Singleton？"><a href="#如何在Java中创建线程安全的Singleton？" class="headerlink" title="如何在Java中创建线程安全的Singleton？"></a>如何在Java中创建线程安全的Singleton？</h4><blockquote><p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。</p></blockquote><h4 id="什么是多线程的上下文切换？"><a href="#什么是多线程的上下文切换？" class="headerlink" title="什么是多线程的上下文切换？"></a>什么是多线程的上下文切换？</h4><blockquote><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p></blockquote><h4 id="写出3条你遵循的多线程最佳实践"><a href="#写出3条你遵循的多线程最佳实践" class="headerlink" title="写出3条你遵循的多线程最佳实践"></a>写出3条你遵循的多线程最佳实践</h4><blockquote><p>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p><ul><li><p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p></li><li><p>避免锁定和缩小同步的范围</p></li></ul><p>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p><ul><li>多用同步类少用wait 和 notify</li></ul><p>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p><ul><li>多用并发集合少用同步集合</li></ul><p>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</p></blockquote><h4 id="Java中的fork-join框架是什么？"><a href="#Java中的fork-join框架是什么？" class="headerlink" title="Java中的fork join框架是什么？"></a>Java中的fork join框架是什么？</h4><blockquote><p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。</p></blockquote><h4 id="Java中如何获取到线程dump文件？"><a href="#Java中如何获取到线程dump文件？" class="headerlink" title="Java中如何获取到线程dump文件？"></a>Java中如何获取到线程dump文件？</h4><blockquote><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><ul><li>获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</li><li>打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</li></ul><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。</p></blockquote><h4 id="Linux环境下如何查找哪个线程使用CPU最长"><a href="#Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="Linux环境下如何查找哪个线程使用CPU最长?"></a>Linux环境下如何查找哪个线程使用CPU最长?</h4><blockquote><p>这是一个比较偏实践的问题，可以这么做：</p><ul><li>获取项目的pid，jps或者ps -ef | grep java</li><li>top -H -p pid，顺序不能改变</li></ul><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号。<br>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。<br>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p></blockquote><h4 id="Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？"><a href="#Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？" class="headerlink" title="Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？"></a>Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</h4><blockquote><ul><li>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</li><li>CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。</li></ul></blockquote><h4 id="同步方法和同步块，哪个是更好的选择"><a href="#同步方法和同步块，哪个是更好的选择" class="headerlink" title="同步方法和同步块，哪个是更好的选择?"></a>同步方法和同步块，哪个是更好的选择?</h4><blockquote><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。<br>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p></blockquote><h4 id="终止正在运行的线程的三种方法"><a href="#终止正在运行的线程的三种方法" class="headerlink" title="终止正在运行的线程的三种方法"></a>终止正在运行的线程的三种方法</h4><blockquote><ul><li>使用退出标志，是线程正常退出，也就是当run方法完成后线程终止；</li><li>使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样都是作废过期的方法，使用它们可能产生不可预料的结果；</li><li>使用interrupt方法中断线程；（推荐）</li></ul></blockquote><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><blockquote><p>Java中线程的优先级分为1-10这10个等级，如果小于1或大于10则JDK抛出IllegalArgumentException()的异常，默认优先级是5。在Java中线程的优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。注意程序正确性不能依赖线程的优先级高低，因为操作系统可以完全不理会Java线程对于优先级的决定。</p></blockquote><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><blockquote><p>Java中有两种线程，一种是用户线程，另一种是守护线程。当进程中不存在非守护线程了，则守护线程自动销毁。通过setDaemon(true)设置线程为后台线程。注意thread.setDaemon(true)必须在thread.start()之前设置，否则会报IllegalThreadStateException异常；在Daemon线程中产生的新线程也是Daemon的；在使用ExecutorSerice等多线程框架时，会把守护线程转换为用户线程，并且也会把优先级设置为Thread.NORM_PRIORITY。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p></blockquote><h4 id="synchronized的类锁与对象锁"><a href="#synchronized的类锁与对象锁" class="headerlink" title="synchronized的类锁与对象锁"></a>synchronized的类锁与对象锁</h4><blockquote><ul><li><p>类锁：在方法上加上static synchronized的锁，或者synchronized(xxx.class)的锁。如下代码中的method1和method2：</p></li><li><p>对象锁：参考method4, method5,method6.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockStrategy</span> </span>&#123;</span><br><span class="line">&gt;     </span><br><span class="line">&gt;    <span class="keyword">public</span> Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">synchronized</span>(LockStrategy.class)&#123;&#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;&#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">synchronized</span>(object1)&#123;&#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>注意方法method4和method5中的同步块也是互斥的。</p></blockquote><h4 id="同步不具备继承性"><a href="#同步不具备继承性" class="headerlink" title="同步不具备继承性"></a>同步不具备继承性</h4><blockquote><p>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。同步不具有继承性（声明为synchronized的父类方法A，在子类中重写之后并不具备synchronized的特性）。</p></blockquote><h4 id="不同线程间的通信问题"><a href="#不同线程间的通信问题" class="headerlink" title="不同线程间的通信问题"></a>不同线程间的通信问题</h4><blockquote><p>在Java中提供了各种各样的输入/输出流Stream，使我们能够很方便地对数据进行操作，其中管道流（pipeStream)是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道中读数据，通过使用管道，实现不同线程间的通信，而无须借助类似临时文件之类的东西。在JDK中使用4个类来使线程间可以进行通信：PipedInputStream, PipedOutputStream, PipedReader, PipedWriter。使用代码类似inputStream.connect(outputStream)或outputStream.connect(inputStream)使两个Stream之间产生通信连接。</p><p><strong>几种进程间的通信方式</strong></p><ul><li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li><li>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li></ul></blockquote><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><blockquote><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。join与synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键字使用的是“对象监视器”做为同步。<br>join提供了另外两种实现方法：join(long millis)和join(long millis, int nanos)，至多等待多长时间而退出等待(释放锁)，退出等待之后还可以继续运行。内部是通过wait方法来实现的。</p></blockquote><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><blockquote><p>ThreadLocal可以实现每个线程绑定自己的值，即每个线程有各自独立的副本而互相不受影响。一共有四个方法：get, set, remove, initialValue。可以重写initialValue()方法来为ThreadLocal赋初值。<br>ThreadLocal建议设置为static类型的。<br>使用类InheritableThreadLocal可以在子线程中取得父线程继承下来的值。可以采用重写childValue（Object parentValue）方法来更改继承的值。<br>注意：在线程池的情况下，在ThreadLocal业务周期处理完成时，最好显式的调用remove()方法，清空”线程局部变量”中的值。正常情况下使用ThreadLocal不会造成内存溢出，弱引用的只是threadLocal，保存的值依然是强引用的，如果threadLocal依然被其他对象强引用，”线程局部变量”是无法回收的。</p></blockquote><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><blockquote><p>ReentrantLock提供了tryLock方法，tryLock调用的时候，如果锁被其他线程持有，那么tryLock会立即返回，返回结果为false；如果锁没有被其他线程持有，那么当前调用线程会持有锁，并且tryLock返回的结果为true。<br>可以在构造ReentranLock时使用公平锁，公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。synchronized中的锁时非公平的，默认情况下ReentrantLock也是非公平的，但是可以在构造函数中指定使用公平锁。<br>对于ReentrantLock来说，还有一个十分实用的特性，它可以同时绑定多个Condition条件，以实现更精细化的同步控制。<br>ReentrantLock使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">&gt; lock.lock();</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&gt;     lock.unlock();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="ReentrantLock中的其余方法"><a href="#ReentrantLock中的其余方法" class="headerlink" title="ReentrantLock中的其余方法"></a>ReentrantLock中的其余方法</h4><blockquote><ul><li>int getHoldCount()：查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。</li><li>int getQueueLength()：返回正等待获取此锁定的线程估计数。比如有5个线程，1个线程首先执行await()方法，那么在调用getQueueLength方法后返回值是4，说明有4个线程在等待lock的释放。</li><li>int getWaitQueueLength(Condition condition)：返回等待此锁定相关的给定条件Condition的线程估计数。比如有5个线程，每个线程都执行了同一个condition对象的await方法，则调用getWaitQueueLength(Condition condition)方法时返回的int值是5。</li><li>boolean hasQueuedThread(Thread thread)：查询指定线程是否正在等待获取此锁定。</li><li>boolean hasQueuedThreads()：查询是否有线程正在等待获取此锁定。</li><li>boolean hasWaiters(Condition condition)：查询是否有线程正在等待与此锁定有关的condition条件。</li><li>boolean isFair()：判断是不是公平锁。</li><li>boolean isHeldByCurrentThread()：查询当前线程是否保持此锁定。</li><li>boolean isLocked()：查询此锁定是否由任意线程保持。</li><li>void lockInterruptibly()：如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常。</li></ul></blockquote><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><blockquote><p>一个Condition和一个Lock关联在一起，就想一个条件队列和一个内置锁相关联一样。要创建一个Condition，可以在相关联的Lock上调用Lock.newCondition方法。正如Lock比内置加锁提供了更为丰富的功能，Condition同样比内置条件队列提供了更丰富的功能：在每个锁上可存在多个等待、条件等待可以是可中断的或者不可中断的、基于时限的等待，以及公平的或非公平的队列操作。与内置条件队列不同的是，对于每个Lock，可以有任意数量的Condition对象。Condition对象继承了相关的Lock对象的公平性，对于公平的锁，线程会依照FIFO顺序从Condition.await中释放。<br>注意：在Condition对象中，与wait,notify和notifyAll方法对于的分别是await,signal,signalAll。但是，Condition对Object进行了扩展，因而它也包含wait和notify方法。一定要确保使用的版本——await和signal.</p></blockquote><h4 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h4><blockquote><p>读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排它锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有Thread进行写操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁后才能进行写入操作。即读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。(lock.readlock.lock(), lock.readlock.unlock, lock.writelock.lock, lock.writelock.unlock)。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排它锁有了很大的提升。Java中使用ReentrantReadWriteLock实现读写锁。</p></blockquote><h4 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h4><blockquote><p>建议不要采用DCL的写法，建议使用下面这种静态内部类写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">&gt;     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>或者这种枚举式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</span><br><span class="line">&gt;     INSTANCE;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="线程组ThreadGroup"><a href="#线程组ThreadGroup" class="headerlink" title="线程组ThreadGroup"></a>线程组ThreadGroup</h4><blockquote><p>为了有效地对一些线程进行组织管理，通常的情况下事创建一个线程组，然后再将部分线程归属到该组中，这样可以对零散的线程对象进行有效的组织和规划。</p></blockquote><h4 id="ReentrantLock与synchonized区别"><a href="#ReentrantLock与synchonized区别" class="headerlink" title="ReentrantLock与synchonized区别"></a>ReentrantLock与synchonized区别</h4><blockquote><ul><li>ReentrantLock可以中断地获取锁（void lockInterruptibly() throws InterruptedException）</li><li>ReentrantLock可以尝试非阻塞地获取锁（boolean tryLock()）</li><li>ReentrantLock可以超时获取锁。通过tryLock(timeout, unit)，可以尝试获得锁，并且指定等待的时间。</li><li>ReentrantLock可以实现公平锁。通过new ReentrantLock(true)实现。</li><li>ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的的wait(), notify(), notifyAll()方法可以实现一个隐含条件，如果要和多于一个的条件关联的对象，就不得不额外地添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法即可。</li></ul></blockquote><h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><blockquote><p>锁降级是指写锁降级成读锁。如果当前线程拥有写锁，然后将其释放，最后获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，最后释放（先前拥有的）写锁的过程。<br>锁降级中的读锁是否有必要呢？答案是必要。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p></blockquote><h4 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h4><blockquote><ul><li>ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列。 </li><li>LinkedeBlockingQueue:一个有链表结构组成的有界阻塞队列。 </li><li>PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列 </li><li>DelayQueue:一个使用优先级队列实现的无界阻塞队列。 </li><li>SynchronousQueue:一个不存储元素的阻塞队列。 </li><li>LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。 </li><li>LinkedBlockingDeque:一个由链表结构组成的双向阻塞队列。</li></ul></blockquote><h4 id="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"><a href="#高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"></a>高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h4><blockquote><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><ul><li>高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</li><li>并发不高、任务执行时间长的业务要区分开看：</li><li>假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</li><li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li><li>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考第二条。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是线程？&quot;&gt;&lt;a href=&quot;#什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程？&quot;&gt;&lt;/a&gt;什么是线程？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="多线程" scheme="http://dijia478.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git快速入门和常用命令</title>
    <link href="http://dijia478.cn//blog/2015/10/03/2015-10-03-Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://dijia478.cn//blog/2015/10/03/2015-10-03-Git快速入门和常用命令/</id>
    <published>2015-10-03T03:02:18.000Z</published>
    <updated>2018-01-02T05:45:25.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易图解git流程概念"><a href="#简易图解git流程概念" class="headerlink" title="简易图解git流程概念"></a>简易图解git流程概念</h2><img src="/blog/2015/10/03/2015-10-03-Git快速入门和常用命令/git01.png"><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：本地仓库区（用HEAD指向最后一次commit的结果）</li><li>Remote：远程仓库<a id="more"></a></li></ul><h2 id="一、快速入门"><a href="#一、快速入门" class="headerlink" title="一、快速入门"></a>一、快速入门</h2><h3 id="本地初始化一个项目"><a href="#本地初始化一个项目" class="headerlink" title="本地初始化一个项目"></a>本地初始化一个项目</h3><p>首先，你需要执行下面两条命令，作为 git 的基础配置，作用是告诉 git 你是谁，你输入的信息将出现在你创建的提交中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">"你的名字或昵称"</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">"你的邮箱"</span></span><br></pre></td></tr></table></figure><p>然后在你的需要初始化版本库的文件夹中执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br><span class="line">git remote add origin 你的项目地址 <span class="comment"># 项目地址形式为:http://git.oschina.net/xxx/xxx.git或者 git@git.oschina.net:xxx/xxx.git</span></span><br></pre></td></tr></table></figure><p>这样就完成了一次版本你的初始化。</p><p>如果你想克隆一个项目，只需要执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 项目地址</span><br></pre></td></tr></table></figure><h3 id="完成第一次提交"><a href="#完成第一次提交" class="headerlink" title="完成第一次提交"></a>完成第一次提交</h3><p>进入你已经初始化好的或者克隆项目的目录，然后执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master　　<span class="comment"># 从远程仓库获取最新版本并合并，因为你提交前可能已经有别人提交过了，你需要合并最新版本才能提交到远程仓库</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"这是我第一次提交的说明"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>然后如果需要账号密码的话就输入账号密码，这样就完成了一次提交。</p><h2 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">git config -e [--<span class="keyword">global</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">"[name]"</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure><h3 id="获取与创建本地项目"><a href="#获取与创建本地项目" class="headerlink" title="获取与创建本地项目"></a>获取与创建本地项目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init    <span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">git init 目录    <span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 项目地址URL    <span class="comment"># 拷贝一个Git仓库到本地</span></span><br></pre></td></tr></table></figure><p>默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。URL也可以是你的本地仓库地址，这样就是创建了一个本地仓库的克隆版本。</p><h3 id="增加-删除文件到Index"><a href="#增加-删除文件到Index" class="headerlink" title="增加/删除文件到Index"></a>增加/删除文件到Index</h3><p>你可以计划改动（把它们添加到缓存区），使用如下命令：<br><strong>git add [filename]</strong><br><strong>git add . </strong><br>这是 git 基本工作流程的第一步；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把文件从暂存区域移除，但保留在当前工作目录中</span></span><br><span class="line">git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</span></span><br><span class="line">git rm -f [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除整个目录中的所有子目录和文件</span></span><br><span class="line">git rm –r * </span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><p>使用如下命令以实际提交改动：<br><strong>git commit -m “代码提交信息”</strong><br>现在，你的改动已经提交到了 <strong>HEAD</strong>，但是还没到你的远端仓库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区，并填写备注信息</span></span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h3 id="同步远程仓库"><a href="#同步远程仓库" class="headerlink" title="同步远程仓库"></a>同步远程仓库</h3><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：<br><strong>git push origin master</strong><br>可以把 master 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<br><strong>git remote add origin [server]</strong><br>如此你就能够将你的改动推送到所添加的服务器上去了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前配置有哪些远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">git push [remote] --all</span><br></pre></td></tr></table></figure><p>要更新你的本地仓库至最新改动，执行：<br><strong>git pull</strong><br>以在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：<br><strong>git merge [branch]</strong><br>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 <em>冲突（conflicts）</em>。 这时候就需要你修改这些文件来人肉合并这些 <em>冲突（conflicts）</em> 了。改完之后，你需要执行如下命令以将它们标记为合并成功：<br><strong>git add [filename]</strong><br>在合并改动之前，也可以使用如下命令查看：<br><strong>git diff  {source_branch} {target_branch}</strong></p><h2 id="三、查看信息"><a href="#三、查看信息" class="headerlink" title="三、查看信息"></a>三、查看信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录所有还没有被git管理的文件和被git管理且被修改但还未提交(git commit)的文件,-s参数可简化显示</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="四、撤销"><a href="#四、撤销" class="headerlink" title="四、撤销"></a>四、撤销</h2><p>假如你做错事，你可以使用如下命令替换掉本地改动：<br><strong>git checkout –[filename]</strong><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p><p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：<br><strong>git fetch origin</strong><br><strong>git reset –hard origin/master</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h2 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。<br>创建一个叫做“feature_x”的分支，并切换过去：<br><strong>git checkout -b feature_x</strong><br>切换回主分支：<br><strong>git checkout master</strong><br>再把新建的分支删掉：<br><strong>git branch -d feature_x</strong><br>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：<br><strong>git push origin [branch]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h2 id="六、历史记录"><a href="#六、历史记录" class="headerlink" title="六、历史记录"></a>六、历史记录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出历史提交记录</span></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">git log --stat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史记录的简洁的版本</span></span><br><span class="line">git log --oneline    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史中什么时候出现了分支、合并</span></span><br><span class="line">git log --oneline --graph    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆向显示所有日志</span></span><br><span class="line">git log --reverse --oneline    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史中什么时候出现了分支、合并</span></span><br><span class="line">git log --oneline --graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">git log -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">git log -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line">git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">git log --follow [file]</span><br><span class="line">git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">git log <span class="number">-5</span> --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找指定用户的提交日志，看5条</span></span><br><span class="line">git log --author=用户名 --oneline <span class="number">-5</span>   </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看3周前且在10月01日之后的所有提交，--no-merges 选项以隐藏合并提交</span></span><br><span class="line">git log --oneline --before=&#123;<span class="number">3.</span>weeks.ago&#125; --after=&#123;<span class="number">2015</span><span class="number">-10</span><span class="number">-01</span>&#125; --no-merges</span><br></pre></td></tr></table></figure><h2 id="七、标签"><a href="#七、标签" class="headerlink" title="七、标签"></a>七、标签</h2><p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签：<br><strong>git tag 1.0.0 1b2e1d63ff</strong><br>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：<br><strong>git log</strong><br>你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line"><span class="comment"># -a 选项意为"创建一个带注解的标签"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签</span></span><br><span class="line">git tag -a [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><p>Git有commit，为什么还要引入tag？<br>“请把上周一的那个版本打包发布，commit号是6a5819e…”<br>“一串乱七八糟的数字不好找！”<br>如果换一个办法：<br>“请把上周一的那个版本打包发布，版本号是v1.2”<br>“好的，按照tag v1.2查找commit就行！”<br>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h2 id="八、http-s-方式如何自动记住密码"><a href="#八、http-s-方式如何自动记住密码" class="headerlink" title="八、http(s)方式如何自动记住密码"></a>八、http(s)方式如何自动记住密码</h2><p>https 方式每次都要输入密码，按照如下设置即可输入一次就不用再手输入密码的困扰而且又享受 https 带来的极速</p><p>按照以下设置记住密码十五分钟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> credential.helper cache</span><br></pre></td></tr></table></figure><p>如果你想自定义记住的时间，可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config credential.helper <span class="string">'cache --timeout=3600'</span> <span class="comment"># 这里记住的是一个小时，如需其他时间，请修改3600为你想修改的时间，单位是秒</span></span><br></pre></td></tr></table></figure><p>你也可以设置长期记住密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> credential.helper store</span><br></pre></td></tr></table></figure><p>或修改仓库的地址带上你的账号密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://yourname:password@git.oschina.net/name/project.git <span class="comment"># 注意，在码云上使用邮箱时，请对@符号使用%40替换</span></span><br></pre></td></tr></table></figure><p>如果你原本使用的 ssh 地址想更换成 http(s) 地址，可以执行以下命令:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除原本的ssh仓库地址</span></span><br><span class="line">git remote rm origin <span class="comment"># origin 代表你原本ssh地址的仓库的别名</span></span><br><span class="line"><span class="comment"># 新增http地址的仓库</span></span><br><span class="line">git remote add origin http://git.oschina.net/username/project.git</span><br></pre></td></tr></table></figure><h2 id="九、版本回退"><a href="#九、版本回退" class="headerlink" title="九、版本回退"></a>九、版本回退</h2><h3 id="回退远程仓库的版本"><a href="#回退远程仓库的版本" class="headerlink" title="回退远程仓库的版本"></a>回退远程仓库的版本</h3><p>先在本地切换到远程仓库要回退的分支对应的本地分支，然后本地回退至你需要的版本，然后执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;仓库名&gt; &lt;分支名&gt; -f</span><br></pre></td></tr></table></figure><h3 id="以当前版本为基础，回退指定个commit"><a href="#以当前版本为基础，回退指定个commit" class="headerlink" title="以当前版本为基础，回退指定个commit"></a>以当前版本为基础，回退指定个commit</h3><p>首先，确认你当前的版本需要回退多少个版本，然后计算出你要回退的版本数量，执行如下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~X <span class="comment"># X代表你要回退的版本数量，是数字！！！！</span></span><br></pre></td></tr></table></figure><p>需要注意的是，如果你是合并过分支，那么被合并分支带过来的 commit 并不会被计入回退数量中，而是只计算一个，所以如果需要一次回退多个 commit，不建议使用这种方法</p><h3 id="回退到和远程版本一样"><a href="#回退到和远程版本一样" class="headerlink" title="回退到和远程版本一样"></a>回退到和远程版本一样</h3><p>有时候，当发生错误修改需要放弃全部修改时，可以以远程分支作为回退点退回到与远程分支一样的地方，执行的命令如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard origin/master <span class="comment"># origin代表你远程仓库的名字，master代表分支名</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简易图解git流程概念&quot;&gt;&lt;a href=&quot;#简易图解git流程概念&quot; class=&quot;headerlink&quot; title=&quot;简易图解git流程概念&quot;&gt;&lt;/a&gt;简易图解git流程概念&lt;/h2&gt;&lt;img src=&quot;/blog/2015/10/03/2015-10-03-Git快速入门和常用命令/git01.png&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Workspace：工作区&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区&lt;/li&gt;
&lt;li&gt;Repository：本地仓库区（用HEAD指向最后一次commit的结果）&lt;/li&gt;
&lt;li&gt;Remote：远程仓库
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="Git" scheme="http://dijia478.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分支的学习笔记整理</title>
    <link href="http://dijia478.cn//blog/2015/09/21/2015-09-21-Git%E5%88%86%E6%94%AF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://dijia478.cn//blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/</id>
    <published>2015-09-21T05:44:14.000Z</published>
    <updated>2018-01-02T14:09:02.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。<br><a id="more"></a><br>有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。</p><h2 id="何谓分支"><a href="#何谓分支" class="headerlink" title="何谓分支"></a>何谓分支</h2><p>Git 保存的不是文件差异或者变化量，而只是一系列文件快照。</p><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><p>为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（SHA-1 哈希字串），然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m <span class="string">'initial commit of my project'</span></span><br></pre></td></tr></table></figure><p>当使用 <code>git commit</code> 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p><p>现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图 1 所示：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi01.png" title="图1.单个提交对象在仓库中的数据结构"><p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（即下图中的 parent 对象）。两次提交后，仓库历史会变成图 2 的样子：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi02.png" title="图2.多个提交对象之间的链接关系"><p>现在来谈分支。Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi03.png" title="图3.分支其实就是从某个提交对象往回看的历史"><p>那么，Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 <code>git branch</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure><p>这会在当前 commit 对象上新建一个分支指针（见图 4）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi04.png" title="图4.多个分支指向提交数据的历史"><p>那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。请注意它和你熟知的许多其他版本控制系统（比如 Subversion 或 CVS）里的 HEAD 概念大不相同。在 Git 中，它是一个指向你正在工作中的本地分支的指针（将 HEAD 想象为当前分支的别名）。运行 <code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作（参考图 5）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi05.png" title="图5.HEAD 指向当前所在的分支"><p>要切换到其他分支，可以执行 <code>git checkout</code> 命令。我们现在转换到新建的 testing 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure><p>这样 HEAD 就指向了 testing 分支（见图 6）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi06.png" title="图6.HEAD 在你转换分支时指向新的分支"><p>这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m <span class="string">'made a change'</span></span><br></pre></td></tr></table></figure><p>图 7 展示了提交后的结果。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi07.png" title="图7.每次提交后 HEAD 随着分支一起向前移动"><p>非常有趣，现在 testing 分支向前移动了一格，而 master 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。现在我们回到 master 分支看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>图 8 显示了结果。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi08.png" title="图8.HEAD 在一次 checkout 之后移动到了另一个分支"><p>这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</p><p>我们作些修改后再次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m <span class="string">'made other changes'</span></span><br></pre></td></tr></table></figure><p>现在我们的项目提交历史产生了分叉（如图 9 所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要 <code>branch</code> 和 <code>checkout</code> 这两条命令就可以完成。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi09.png" title="图9.不同流向的分支历史"><p>由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，当然也就很快了。</p><p>这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间也会有相当大的差别，快则几秒，慢则数分钟。而 Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（即 <code>parent</code> 对象），将来要合并分支时，寻找恰当的合并基础（即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是因为有着这些特性作保障。</p><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p><ol><li>返回到原先已经发布到生产服务器上的分支。</li><li>为这次紧急修补建立一个新分支，并在其中修复问题。</li><li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li><li>切换到之前实现新需求的分支，继续工作。</li></ol><h3 id="分支的新建与切换"><a href="#分支的新建与切换" class="headerlink" title="分支的新建与切换"></a>分支的新建与切换</h3><p>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图 10）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi10.png" title="图10.一个简短的提交历史"><p>现在，你决定要修补问题追踪系统上的 #53 问题。顺带说明下，Git 并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为 iss53。要新建并切换到该分支，运行 <code>git checkout</code> 并加上 <code>-b</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch <span class="string">'iss53'</span></span><br></pre></td></tr></table></figure><p>这相当于执行下面这两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure><p>图 11 示意该命令的执行结果。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi11.png" title="图11.创建了一个新分支的指针"><p>接着你开始尝试修复问题，在提交了若干次更新后，<code>iss53</code> 分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 <code>HEAD</code> 指针正指向 <code>iss53</code>，见图 12）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m <span class="string">'added a new footer [issue 53]'</span></span><br></pre></td></tr></table></figure><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi12.png" title="图12.iss53 分支随工作进展向前推进"><p>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 <code>iss53</code> 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回 <code>master</code> 分支。</p><p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做 stashing 和 commit amending）。目前已经提交了所有的修改，所以接下来可以正常转换到 <code>master</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure><p>此时工作目录中的内容和你在解决问题 #53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p><p>接下来，你得进行紧急修补。我们创建一个紧急修补分支 <code>hotfix</code> 来开展工作，直到搞定（见图 13）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch <span class="string">'hotfix'</span></span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m <span class="string">'fixed the broken email address'</span></span><br><span class="line">[hotfix 3a0874c] fixed the broken email address</span><br><span class="line"> 1 files changed, 1 deletion(-)</span><br></pre></td></tr></table></figure><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi13.png" title="图13.hotfix 分支是从 master 分支所在点分化出来的"><p>有必要作些测试，确保修补是成功的，然后回到 <code>master</code> 分支并把它合并进来，然后发布到生产服务器。用 <code>git merge</code> 命令来进行合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 1 -</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure><p>请注意，合并时出现了“Fast forward”的提示。由于当前 <code>master</code> 分支所在的提交对象是要并入的 <code>hotfix</code> 分支的直接上游，Git 只需把 <code>master</code> 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p><p>现在最新的修改已经在当前 <code>master</code> 分支所指向的提交对象中了，可以部署到生产服务器上去了（见图 14）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi14.png" title="图14.合并之后 master 分支和 hotfix 分支指向同一位置"><p>在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 <code>hotfix</code> 分支和 <code>master</code> 都指向相同的提交对象，所以 <code>hotfix</code> 已经完成了历史使命，可以删掉了。使用 <code>git branch</code> 的 <code>-d</code> 选项执行删除操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was 3a0874c).</span><br></pre></td></tr></table></figure><p>现在回到之前未完成的 #53 问题修复分支上继续工作（图 15）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch <span class="string">'iss53'</span></span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m <span class="string">'finished the new footer [issue 53]'</span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi15.png" title="图15.iss53 分支可以不受影响继续推进"><p>值得注意的是之前 <code>hotfix</code> 分支的修改内容尚未包含到 <code>iss53</code> 中来。如果需要纳入此次修补，可以用 <code>git merge master</code> 把 master 分支合并到 <code>iss53</code>；或者等 <code>iss53</code> 完成之后，再将 <code>iss53</code> 分支中的更新并入 <code>master</code>。</p><h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>在问题 #53 相关的工作完成之后，可以合并回 <code>master</code> 分支。实际操作同前面合并 <code>hotfix</code> 分支差不多，只需回到 <code>master</code> 分支，运行 <code>git merge</code> 命令指定要合并进来的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging README</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> README | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>请注意，这次合并操作的底层实现，并不同于之前 <code>hotfix</code> 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 <code>master</code> 分支所指向的提交对象（C4）并不是 <code>iss53</code> 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 16 用红框标出了 Git 用于合并的三个提交对象：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi16.png" title="图16.Git 为分支合并自动识别出最佳的同源合并点"><p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p><p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi17.png" title="图17.Git 自动创建了一个包含了合并结果的提交对象"><p>既然之前的工作成果已经合并到 <code>master</code> 了，那么 <code>iss53</code> 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d iss53</span><br></pre></td></tr></table></figure><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了 <code>hotfix</code> 中修改的部分，将得到类似下面的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> index.html</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <code>git status</code>查阅：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">  please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</span><br></pre></td></tr></table></figure><p>可以看到 <code>=======</code> 隔开的上半部分，是 <code>HEAD</code>（即 <code>master</code> 分支，在运行 <code>merge</code> 命令时所切换到的分支）中的内容，下半部分是在 <code>iss53</code> 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行。在解决了所有文件里的所有冲突后，运行 <code>git add</code> 将把它们标记为已解决状态（注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行 <code>git mergetool</code>，它会调用一个可视化的合并工具并引导你解决所有冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br><span class="line"></span><br><span class="line">This message is displayed because <span class="string">'merge.tool'</span> is not configured.</span><br><span class="line">See <span class="string">'git mergetool --tool-help'</span> or <span class="string">'git help config'</span> <span class="keyword">for</span> more details.</span><br><span class="line"><span class="string">'git mergetool'</span> will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict <span class="keyword">for</span> <span class="string">'index.html'</span>:</span><br><span class="line">  &#123;<span class="built_in">local</span>&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit <span class="built_in">return</span> to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure><p>如果不想用默认的合并工具（Git 为我默认选择了 <code>opendiff</code>，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。</p><p>退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。</p><p>再运行一次 <code>git status</code> 来确认所有冲突都已解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   index.html</span><br></pre></td></tr></table></figure><p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 <code>git commit</code> 来完成这次合并提交。提交的记录差不多是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Merge branch <span class="string">'iss53'</span></span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">  index.html</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It looks like you may be committing a merge.</span></span><br><span class="line"><span class="comment"># If this is not correct, please remove the file</span></span><br><span class="line"><span class="comment">#       .git/MERGE_HEAD</span></span><br><span class="line"><span class="comment"># and try again.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。</p><h2 id="分支的管理"><a href="#分支的管理" class="headerlink" title="分支的管理"></a>分支的管理</h2><p>到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。</p><p><code>git branch</code> 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>注意看 <code>master</code> 分支前的 <code>*</code> 字符：它表示当前所在的分支。也就是说，如果现在提交更新，<code>master</code> 分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行 <code>git branch -v</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch <span class="string">'iss53'</span></span><br><span class="line">  testing 782fd34 add scott to the author list <span class="keyword">in</span> the readmes</span><br></pre></td></tr></table></figure><p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 <code>--merged</code> 和 <code>--no-merged</code> 选项（Git 1.5.6 以上版本）。比如用 <code>git branch --merged</code> 查看哪些分支已被并入当前分支（也就是说哪些分支是当前分支的直接上游。）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>之前我们已经合并了 <code>iss53</code>，所以在这里会看到它。一般来说，列表中没有 <code>*</code> 的分支通常都可以用 <code>git branch -d</code> 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。</p><p>另外可以用 <code>git branch --no-merged</code> 查看尚未合并的工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 <code>git branch -d</code> 删除该分支会提示错误，因为那样做会丢失数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">error: The branch <span class="string">'testing'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D testing'</span>.</span><br></pre></td></tr></table></figure><p>不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 <code>-D</code> 强制执行，就像上面提示信息中给出的那样。</p><h2 id="利用分支进行开发的工作流程"><a href="#利用分支进行开发的工作流程" class="headerlink" title="利用分支进行开发的工作流程"></a>利用分支进行开发的工作流程</h2><p>现在我们已经学会了新建分支和合并分支，可以（或应该）用它来做点什么呢？我会介绍一些利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。</p><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。</p><p>许多使用 Git 的开发者都喜欢用这种方式来开展工作，比如仅在 <code>master</code> 分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为 <code>develop</code> 或 <code>next</code> 的平行分支，专门用于后续的开发，或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到 <code>master</code> 里。这样，在确保这些已完成的特性分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。</p><p>本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前（见图 18）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi18.png" title="图18.稳定分支总是比较老旧"><p>或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图 19）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi19.png" title="图19.想象成流水线可能会容易点"><p>你可以用这招维护不同层次的稳定性。某些大项目还会有个 <code>proposed</code>（建议）或 <code>pu</code>（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入 <code>next</code> 或 <code>master</code> 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。</p><h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。</p><p>我们在上节的例子里已经见过这种用法了。我们创建了 <code>iss53</code> 和 <code>hotfix</code> 这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换 — 因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。</p><p>现在我们来看一个实际的例子。请看图 20，由下往上，起先我们在 <code>master</code> 工作到 C1，然后开始一个新分支 <code>iss91</code> 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支 <code>iss91v2</code>，干到 C8 的时候，又回到主干 <code>master</code> 中提交了 C9 和 C10，再回到 <code>iss91v2</code> 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 <code>master</code> 的最新提交 C10 处开了个新的分支 <code>dumbidea</code> 做些试验。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi20.png" title="图20.拥有多个特性分支的提交历史"><p>现在，假定两件事情：我们最终决定使用第二个解决方案，即 <code>iss91v2</code> 中的办法；另外，我们把 <code>dumbidea</code> 分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的 <code>iss91</code> 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成图 21 这样：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi21.png" title="图21.合并了 dumbidea 和 iss91v2 后的分支历史"><p>请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p><p>我们用 <code>(远程仓库名)/(分支名)</code> 这样的形式表示远程分支。比如我们想看看上次同 <code>origin</code> 仓库通讯时 <code>master</code> 分支的样子，就应该查看 <code>origin/master</code> 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 <code>iss53</code> 分支到远程仓库，虽然你可能也有一个本地的 <code>iss53</code> 分支，但指向服务器上最新更新的却应该是 <code>origin/iss53</code> 分支。</p><p>可能有点乱，我们不妨举例说明。假设你们团队有个地址为 <code>git.ourcompany.com</code> 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为 <code>origin</code>，并下载其中所有的数据，建立一个指向它的 <code>master</code> 分支的指针，在本地命名为 <code>origin/master</code>，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 <code>master</code>分支，始于 <code>origin</code> 上 <code>master</code> 分支相同的位置，你可以就此开始工作（见图 22）：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi22.png" title="图22.一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，并且将它们都指向 origin 上的 master 分支"><p>如果你在本地 <code>master</code> 分支做了些改动，与此同时，其他人向 <code>git.ourcompany.com</code> 推送了他们的更新，那么服务器上的 <code>master</code> 分支就会向前推进，而与此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 <code>origin/master</code> 指针仍然保持原位不会移动（见图 23）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi23.png" title="图23.在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流"><p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。该命令首先找到 <code>origin</code> 是哪个服务器（本例为 <code>git.ourcompany.com</code>），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 <code>origin/master</code> 的指针移到它最新的位置上（见图 24）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi24.png" title="图24.git fetch 命令会更新 remote 索引"><p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 <code>git.team1.ourcompany.com</code>。可以用 <code>git remote add</code> 命令把它加为当前项目的远程分支之一。我们把它命名为 <code>teamone</code>，以便代替完整的 Git URL 以方便使用（见图 25）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi25.png" title="图25.把另一个服务器加为远程仓库"><p>现在你可以用 <code>git fetch teamone</code> 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 <code>origin</code> 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 <code>teamone/master</code> 的远程分支，指向 <code>teamone</code> 服务器上 <code>master</code> 分支所在的提交对象 <code>31b8e</code>（见图 26）。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi26.png" title="图26.你在本地有了一个指向 teamone 服务器上 master 分支的索引"><h3 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h3><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。</p><p>如果你有个叫 <code>serverfix</code> 的分支需要和他人一起开发，可以运行 <code>git push (远程仓库名) (分支名)</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 20, <span class="keyword">done</span>.</span><br><span class="line">Compressing objects: 100% (14/14), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (15/15), 1.74 KiB, <span class="keyword">done</span>.</span><br><span class="line">Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里其实走了一点捷径。Git 自动把 <code>serverfix</code> 分支名扩展为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。以后有机会了再介绍 <code>refs/heads/</code> 的细节，不过一般使用的时候都可以省略它。也可以运行 <code>git push origin serverfix:serverfix</code> 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 <code>awesomebranch</code>，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p><p>接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 <code>origin/serverfix</code>，并指向服务器上 <code>serverfix</code> 所指向的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 20, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (14/14), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (15/15), <span class="keyword">done</span>.</span><br><span class="line">From git@github.com:schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure><p>值得注意的是，在 <code>fetch</code> 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的 <code>serverfix</code> 分支，有的只是一个你无法移动的 <code>origin/serverfix</code> 指针。</p><p>如果要把该远程分支的内容合并到当前分支，可以运行 <code>git merge origin/serverfix</code>。如果想要一份自己的 <code>serverfix</code> 来开发，可以在远程分支的基础上分化出一个新的分支来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">'serverfix'</span></span><br></pre></td></tr></table></figure><p>这会切换到新建的 <code>serverfix</code> 本地分支，其内容同远程分支 <code>origin/serverfix</code> 一致，这样你就可以在里面继续开发了。</p><h3 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h3><p>从远程分支 <code>checkout</code> 出来的本地分支，称为 <em>跟踪分支</em> (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 <code>git pull</code> 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p><p>在克隆仓库时，Git 通常会自动创建一个名为 <code>master</code> 的分支来跟踪 <code>origin/master</code>。这正是 <code>git push</code> 和 <code>git pull</code> 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 <code>origin</code> 上除了 <code>master</code>之外的其它分支。刚才我们已经看到了这样的一个例子：<code>git checkout -b [分支名] [远程名]/[分支名]</code>。如果你有 1.6.2 以上版本的 Git，还可以用 <code>--track</code> 选项简化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">'serverfix'</span></span><br></pre></td></tr></table></figure><p>要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">'sf'</span></span><br></pre></td></tr></table></figure><p>现在你的本地分支 <code>sf</code> 会自动将推送和抓取数据的位置定位到 <code>origin/serverfix</code> 了。</p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 <code>master</code> 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：<code>git push [远程名] :[分支名]</code>。如果想在服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :serverfix</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 <code>git push [远程名] [本地分支]:[远程分支]</code> 语法，如果省略 <code>[本地分支]</code>，那就等于是在说“在这里提取空白然后把它变成<code>[远程分支]</code>”。</p><h2 id="分支的衍合"><a href="#分支的衍合" class="headerlink" title="分支的衍合"></a>分支的衍合</h2><p>把一个分支中的修改整合到另一个分支的办法有两种：<code>merge</code> 和 <code>rebase</code>（<code>rebase</code> 的翻译暂定为“衍合”，大家知道就可以了）。</p><h3 id="基本的衍合操作"><a href="#基本的衍合操作" class="headerlink" title="基本的衍合操作"></a>基本的衍合操作</h3><p>请回顾之前有关合并的一节（见图 27），你会看到开发进程分叉到两个不同分支，又各自提交了更新。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi27.png" title="图27.最初分叉的提交历史"><p>之前介绍过，最容易的整合分支的方法是 <code>merge</code> 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图 28 所示：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi28.png" title="图28.通过合并一个分支来整合分叉了的历史"><p>其实，还有另外一个选择：你可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做<em>衍合（rebase）</em>。有了 <code>rebase</code> 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。</p><p>在上面这个例子中，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <code>experiment</code>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <code>master</code>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <code>experiment</code> 的提交历史，使它成为 <code>master</code> 分支的直接下游，如图 29 所示：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi29.png" title="图29.把 C3 里产生的改变到 C4 上重演一遍"><p>现在回到 <code>master</code> 分支，进行一次快进合并（见图 30）：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi30.png" title="图30.master 分支的快进"><p>现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p><p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的 <code>origin/master</code> 进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p><p>请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p><h3 id="有趣的衍合"><a href="#有趣的衍合" class="headerlink" title="有趣的衍合"></a>有趣的衍合</h3><p>衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图 31 的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支 <code>server</code>，然后提交 C3 和 C4。然后又从 C3 的地方再增加一个 <code>client</code> 分支来对客户端代码进行一些相应修改，所以提交了 C8 和 C9。最后，又回到 <code>server</code> 分支提交了 C10。</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi31.png" title="图31.从一个特性分支里再分出一个特性分支的历史"><p>假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于 <code>client</code> 分支而非 <code>server</code> 分支的改变（即 C8 和 C9），跳过 <code>server</code> 直接放到 <code>master</code> 分支中重演一遍，但这需要用 <code>git rebase</code> 的 <code>--onto</code> 选项指定新的基底分支 <code>master</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto master server client</span><br></pre></td></tr></table></figure><p>这好比在说：“取出 <code>client</code> 分支，找出 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的变化，然后把它们在 <code>master</code> 上重演一遍”。是不是有点复杂？不过它的结果如图 32 所示，非常酷（虽然 <code>client</code> 里的 C8, C9 在 C3 之后，但这仅表明时间上的先后，而非在 C3 修改的基础上进一步改动，因为 <code>server</code> 和 <code>client</code> 这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在 C3 时间点之后，对另外的文件所做的 C8，C9 修改，放到主干重演。）：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi32.png" title="图32.将特性分支上的另一个特性分支衍合到其他分支"><p>现在可以快进 <code>master</code> 分支了（见图 33）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge client</span><br></pre></td></tr></table></figure><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi33.png" title="图33.快进 master 分支，使之包含 client 分支的变化"><p>现在我们决定把 <code>server</code> 分支的变化也包含进来。我们可以直接把 <code>server</code> 分支衍合到 <code>master</code>，而不用手工切换到 <code>server</code> 分支后再执行衍合操作 — <code>git rebase [主分支] [特性分支]</code> 命令会先取出特性分支 <code>server</code>，然后在主分支 <code>master</code> 上重演：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase master server</span><br></pre></td></tr></table></figure><p>于是，<code>server</code> 的进度应用到 <code>master</code> 的基础上，如图 34 所示：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi34.png" title="图34.在 master 分支上衍合 server 分支"><p>然后就可以快进主干分支 <code>master</code> 了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge server</span><br></pre></td></tr></table></figure><p>现在 <code>client</code> 和 <code>server</code> 分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图 35 的样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d client</span><br><span class="line">$ git branch -d server</span><br></pre></td></tr></table></figure><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi35.png" title="图35.最终的提交历史"><h3 id="衍合的风险"><a href="#衍合的风险" class="headerlink" title="衍合的风险"></a>衍合的风险</h3><p>呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：</p><p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p><p>如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p><p>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用 <code>git rebase</code> 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p><p>下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图 36 所示：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi36.png" title="图36.克隆一个仓库，在其基础上工作一番"><p>现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成图 37 这样：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi37.png" title="图37.抓取他人提交，并入自己主干"><p>接下来，那个推送 C6 上来的人决定用衍合取代之前的合并操作；继而又用 <code>git push --force</code> 覆盖了服务器上的历史，得到 C4’。而之后当你再从服务器上下载最新提交后，会得到：</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi38.png" title="图38.有人推送了衍合后得到的 C4" alt="，丢弃了你作为开发基础的 C4 和 C6"><p>下载更新后需要合并，但此时衍合产生的提交对象 C4’ 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4’ 合并为 C8（见图 39）:</p><img src="/blog/2015/09/21/2015-09-21-Git分支的学习笔记整理/gitfenzhi39.png" title="图39.你把相同的内容又合并了一遍，生成一个新的提交 C8"><p>C8 这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在 C8 之后，你的提交历史里就会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，如果用 <code>git log</code> 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务器，进一步困扰其他人（这个例子中，出问题的责任方是那个发布了 C6 后又用衍合发布 C4’ 的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听）。</p><p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p><p>本文参考<a href="http://iissnan.com/progit/" target="_blank" rel="noopener">《Pro Git》</a> 一书</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git-分支&quot;&gt;&lt;a href=&quot;#Git-分支&quot; class=&quot;headerlink&quot; title=&quot;Git 分支&quot;&gt;&lt;/a&gt;Git 分支&lt;/h2&gt;&lt;p&gt;几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="Git" scheme="http://dijia478.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础使用规范</title>
    <link href="http://dijia478.cn//blog/2015/05/26/2015-05-26-MySql%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>http://dijia478.cn//blog/2015/05/26/2015-05-26-MySql基础使用规范/</id>
    <published>2015-05-26T11:41:51.000Z</published>
    <updated>2018-01-03T02:01:57.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h3><p><strong>1、使用InnoDB存储引擎</strong></p><p>支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p><p><strong>2、推荐使用utf8mb4字符集</strong></p><p>无需转码，无乱码风险, 支持emoji表情以及部分不常见汉字</p><p><strong>3、表、字段必须加注释</strong></p><p>方便他人理解字段意思。<br><a id="more"></a><br><strong>4、不在数据库做计算</strong></p><p>禁止使用存储过程、视图、触发器、Event。</p><p>在并发量大的情况下，这些功能很可能将数据库拖跨，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”</p><p><strong>5、禁止存储文件</strong></p><p>文件存储在文件系统，数据库里存URI</p><p><strong>6、控制单表数据量</strong></p><p>单表记录控制在千万级</p><h3 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h3><p><strong>1、库名、表名、字段名：小写，下划线风格</strong></p><p>非唯一索引名idx_xxx，唯一索引名uniq_xxx</p><p><strong>2、表必须有主键，例如自增主键</strong></p><p>a）主键递增，数据行写入可以提高插入性能</p><p>b）主键要选择较短的数据类型，Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率</p><p>c）保证实体的完整性，唯一性</p><p><strong>3、不要使用外键，如果有外键约束，用应用程序控制</strong></p><p>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能下降，大数据高并发业务场景数据库使用以性能优先</p><h3 id="三、字段设计规范"><a href="#三、字段设计规范" class="headerlink" title="三、字段设计规范"></a>三、字段设计规范</h3><p><strong>1、把字段定义为NOT NULL并且提供默认值</strong></p><p>a）null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</p><p>b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多</p><p>c）null值需要更多的存储空间，无论是表还是索引中每行中的null的列都需要额外的空间来标识</p><p>d）对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’zhangsan’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</p><p><strong>2、不要使用TEXT、BLOB类型</strong></p><p>会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能,如果必须要使用则独立出来一张表，用主键来对应，避免影响其它字段索引效率</p><p><strong>3、不要使用小数存储货币</strong></p><p>建议使用整数，小数容易导致钱对不上</p><p><strong>4、必须使用varchar存储手机号</strong></p><p>手机号会去做数学运算么？</p><p><strong>5、为提高效率可以牺牲范式设计，冗余数据</strong></p><p>a）不是频繁修改的字段</p><p>b）不是 varchar 超长字段，更不能是 text 字段</p><h3 id="四、索引设计规范"><a href="#四、索引设计规范" class="headerlink" title="四、索引设计规范"></a>四、索引设计规范</h3><p><strong>1、禁止在更新十分频繁、区分度不高的属性上建立索引</strong></p><p>a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</p><p>b）“性别”这种区分度不大的属性，建立索引是没有什么意义的</p><p><strong>2、建立组合索引，必须把区分度高的字段放在最左边</strong></p><p>如果 where a=? and b=? ， a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可</p><p><strong>3、 页面搜索严禁左模糊或者全模糊</strong></p><p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引, 如果需要请走搜索引擎来解决</p><h3 id="五、SQL使用规范"><a href="#五、SQL使用规范" class="headerlink" title="五、SQL使用规范"></a>五、SQL使用规范</h3><p><strong>1、禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</strong></p><p>a）消耗cpu，io，内存，带宽</p><p>b）不能有效的利用覆盖索引</p><p>c）使用SELECT *容易在增加或者删除字段后出现程序BUG, 不具有扩展性</p><p><strong>2、使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</strong></p><p>容易在增加或者删除字段后出现程序BUG</p><p><strong>3、务必请使用“同类型”进行比较，否则可能全表扫面</strong></p><p>SELECT name FROM t_user WHERE phone=1333333333 会导致全表扫描.</p><p><strong>4、禁止在WHERE条件的上使用函数或者计算</strong></p><p>解读：SELECT naem FROM t_user WHERE date(create_datatime)=’2017-12-15’ 会导致全表扫描</p><p>推荐的写法是：SELECT name FROM t_user WHERE create_datatime&gt;=’2017-02-15’ and create_datatime &lt; ‘2017-02-16 ‘</p><p><strong>5、禁止负向查询，以及%开头的模糊查询</strong></p><p>a）负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</p><p>b）%开头的模糊查询，会导致全表扫描</p><p><strong>6、不要大表使用JOIN查询，禁止大表使用子查询</strong></p><p>会产生临时表，消耗较多内存与CPU，极大影响数据库性能</p><p><strong>7、OR改写为IN()或者UNION</strong></p><p>原因很简单or不会走索引</p><p><strong>8、简单的事务</strong></p><p>事务就像程序中的锁一样粒度尽可能要小</p><p><strong>9、不要一次更新大量数据</strong></p><p>数据更新会对行或者表加锁，应该分为多次更新</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、基础规范&quot;&gt;&lt;a href=&quot;#一、基础规范&quot; class=&quot;headerlink&quot; title=&quot;一、基础规范&quot;&gt;&lt;/a&gt;一、基础规范&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1、使用InnoDB存储引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、推荐使用utf8mb4字符集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无需转码，无乱码风险, 支持emoji表情以及部分不常见汉字&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、表、字段必须加注释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方便他人理解字段意思。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="MySQL" scheme="http://dijia478.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如何正确的写出单例模式</title>
    <link href="http://dijia478.cn//blog/2015/04/18/2015-04-18-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%86%99%E5%87%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://dijia478.cn//blog/2015/04/18/2015-04-18-如何正确的写出单例模式/</id>
    <published>2015-04-18T15:55:26.000Z</published>
    <updated>2017-12-31T13:06:46.279Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。<a id="more"></a></p><h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p><h2 id="懒汉式，双重检验锁"><a href="#懒汉式，双重检验锁" class="headerlink" title="懒汉式，双重检验锁"></a>懒汉式，双重检验锁</h2><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">//Single Checked</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">//Double Checked</span></span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题。主要在于<code>instance = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><ol><li>给 instance 分配内存</li><li>调用 Singleton 的构造函数来初始化成员变量</li><li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li></ol><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p><h2 id="懒汉式，静态内部类-static-nested-class"><a href="#懒汉式，静态内部类-static-nested-class" class="headerlink" title="懒汉式，静态内部类 static nested class"></a>懒汉式，静态内部类 static nested class</h2><p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h2 id="饿汉式-static-final-field"><a href="#饿汉式-static-final-field" class="headerlink" title="饿汉式 static final field"></a>饿汉式 static final field</h2><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p><h2 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum"></a>枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。</p><p>就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="单例模式" scheme="http://dijia478.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.7中HashMap底层实现原理</title>
    <link href="http://dijia478.cn//blog/2015/03/13/2015-03-13-JDK1-7%E4%B8%ADHashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://dijia478.cn//blog/2015/03/13/2015-03-13-JDK1-7中HashMap底层实现原理/</id>
    <published>2015-03-13T10:14:32.000Z</published>
    <updated>2018-01-02T04:21:50.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p>HashMap中的数据结构是数组+单链表的组合，以键值对(key-value)的形式存储元素的，通过put()和get()方法储存和获取对象。<a id="more"></a></p><img src="/blog/2015/03/13/2015-03-13-JDK1-7中HashMap底层实现原理/HashMap01.png"><p>（蓝色方块表示Entry对象，横排红框表示数组table[ ]，纵排绿框表示哈希桶bucket【实际上是一个由Entry组成的链表，新加入的Entry放在链头，最先加入的放在链尾】）</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 初始容量，默认16 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 最大初始容量，2^30 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 负载因子，默认0.75，负载因子越小，hash冲突机率越低 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 初始化一个Entry的空数组 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将初始化好的空数组赋值给table，table数组是HashMap实际存储数据的地方，并不在EMPTY_TABLE数组中 */</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** HashMap实际存储的元素个数 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 临界值（HashMap 实际能存储的大小）,公式为(threshold = capacity * loadFactor) */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 负载因子 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** HashMap的结构被修改的次数，用于迭代器 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断设置的容量和负载因子合不合理</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 设置负载因子，临界值此时为容量大小，后面第一次put时由inflateTable(int toSize)方法计算设置</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>put()源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果table引用指向成员变量EMPTY_TABLE，那么初始化HashMap（设置容量、临界值，新的Entry数组引用）</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若“key为null”，则将该键值对添加到table[0]处，遍历该链表，如果有key为null，则将value替换。没有就创建新Entry对象放在链表表头</span></span><br><span class="line">    <span class="comment">// 所以table[0]的位置上，永远最多存储1个Entry对象，形成不了链表。key为null的Entry存在这里 </span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);  </span><br><span class="line">    <span class="comment">// 若“key不为null”，则计算该key的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);  </span><br><span class="line">    <span class="comment">// 搜索指定hash值在对应table中的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line">    <span class="comment">// 循环遍历table数组上的Entry对象，判断该位置上key是否已存在</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">// 哈希值相同并且对象相同</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            <span class="comment">// 如果这个key对应的键值对已经存在，就用新的value代替老的value，然后退出！</span></span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// table数组中没有key对应的键值对，就将key-value添加到table[i]处 </span></span><br><span class="line">    addEntry(hash, key, value, i);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们给put()方法传递键和值时，HashMap会由key来调用hash()方法，返回键的hash值，计算Index后用于找到bucket（哈希桶）的位置来储存Entry对象。</p><p>如果两个对象key的hash值相同，那么它们的bucket位置也相同，但equals()不相同，添加元素时会发生hash碰撞，也叫hash冲突，HashMap使用链表来解决碰撞问题。</p><p>分析源码可知，put()时，HashMap会先遍历table数组，用hash值和equals()判断数组中是否存在完全相同的key对象， 如果这个key对象在table数组中已经存在，就用新的value代替老的value。如果不存在，就创建一个新的Entry对象添加到table[ i ]处。</p><p>如果该table[ i ]已经存在其他元素，那么新Entry对象将会储存在bucket链表的表头，通过next指向原有的Entry对象，形成链表结构（hash碰撞解决方案）。</p><p>Entry数据结构源码如下（HashMap内部类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       <span class="comment">/** 指向下一个元素的引用 */</span></span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">       <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 构造方法为Entry赋值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">           value = v;</span><br><span class="line">           next = n;</span><br><span class="line">           key = k;</span><br><span class="line">           hash = h;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形成单链表的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Entry添加到数组bucketIndex位置对应的哈希桶中，并判断数组是否需要扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果数组长度大于等于容量×负载因子，并且要添加的位置为null</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 长度扩大为原数组的两倍，代码分析见下面扩容机制</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表中添加一个新的Entry对象在链表的表头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2015/03/13/2015-03-13-JDK1-7中HashMap底层实现原理/HashMap02.png"><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>如果两个不同的key的hashcode相同，两个值对象储存在同一个bucket位置，要获取value，我们调用get()方法，HashMap会使用key的hashcode找到bucket位置，因为HashMap在链表中存储的是Entry键值对，所以找到bucket位置之后，会调用key的equals()方法，按顺序遍历链表的每个 Entry，直到找到想获取的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry 是最早放入该 bucket 中），那HashMap必须循环到最后才能找到该元素。</p><p>get()方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若key为null，遍历table[0]处的链表（实际上要么没有元素，要么只有一个Entry对象），取出key为null的value</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// 若key不为null，用key获取Entry对象</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="comment">// 若链表中找到的Entry不为null，返回该Entry中的value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">// 计算key在数组中对应位置，遍历该位置的链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 若key完全相同，返回链表中对应的Entry对象</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中没找到对应的key，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、hash算法"><a href="#三、hash算法" class="headerlink" title="三、hash算法"></a>三、hash算法</h2><p>我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 </p><p>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns index for hash code h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、性能问题"><a href="#四、性能问题" class="headerlink" title="四、性能问题"></a>四、性能问题</h2><p>HashMap有两个参数影响其性能：初始容量和负载因子。均可以通过构造方法指定大小。</p><p>容量capacity是HashMap中bucket哈希桶(Entry的链表)的数量，初始容量只是HashMap在创建时的容量，最大设置初始容量是2^30，默认初始容量是16（必须为2的幂），解释一下，当数组长度为2的n次幂的时候，不同的key通过indexFor()方法算得的数组位置相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，get()的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p><p>负载因子loadFactor是HashMap在其容量自动增加之前可以达到多满的一种尺度，默认值是0.75。</p><h3 id="扩容机制："><a href="#扩容机制：" class="headerlink" title="扩容机制："></a>扩容机制：</h3><p>当HashMapde的长度超出了加载因子与当前容量的乘积（默认16*0.75=12）时，通过调用resize方法重新创建一个原来HashMap大小的两倍的newTable数组，最大扩容到2^30+1，并将原先table的元素全部移到newTable里面，重新计算hash，然后再重新根据hash分配位置。这个过程叫作rehash，因为它调用hash方法找到新的bucket位置。</p><p>扩容机制源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 如果之前的HashMap已经扩充打最大了，那么就将临界值threshold设置为最大的int值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新传入的newCapacity创建新Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 用来将原先table的元素全部移到newTable里面，重新计算hash，然后再重新根据hash分配位置</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">// 再将newTable赋值给table</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 重新计算临界值，扩容公式在这儿（newCapacity * loadFactor）</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容问题："><a href="#扩容问题：" class="headerlink" title="扩容问题："></a>扩容问题：</h3><p>数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这个操作是极其消耗性能的。所以如果我们已经预知HashMap中元素的个数，那么预设初始容量能够有效的提高HashMap的性能。</p><p>重新调整HashMap大小，当多线程的情况下可能产生条件竞争。因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。</p><h2 id="五、线程安全"><a href="#五、线程安全" class="headerlink" title="五、线程安全"></a>五、线程安全</h2><p>HashMap是线程不安全的，在多线程情况下直接使用HashMap会出现一些莫名其妙不可预知的问题。在多线程下使用HashMap，有几种方案：</p><p>A.在外部包装HashMap，实现同步机制</p><p>B.使用Map m = Collections.synchronizedMap(new HashMap(…));实现同步（官方参考方案，但不建议使用，使用迭代器遍历的时候修改映射结构容易出错）</p><p>D.使用java.util.HashTable，效率最低（几乎被淘汰了）</p><p>E.使用java.util.concurrent.ConcurrentHashMap，相对安全，效率高（建议使用）</p><p>注意一个小问题，HashMap所有集合类视图所返回迭代器都是快速失败的(fail-fast)，在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的 remove 或 add 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。。因此，面对并发的修改，迭代器很快就会完全失败。</p><h2 id="六、关于JDK1-8的问题"><a href="#六、关于JDK1-8的问题" class="headerlink" title="六、关于JDK1.8的问题"></a>六、关于JDK1.8的问题</h2><p>JDK1.8的HashMap源码实现和1.7是不一样的，有很大不同，其底层数据结构也不一样，引入了红黑树结构。有网友测试过，JDK1.8HashMap的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表长度大于8的时候，HashMap会动态的将它替换成一个红黑树（JDK1.8引入红黑树大程度优化了HashMap的性能），这会将时间复杂度从O(n)降为O(logn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据结构&quot;&gt;&lt;a href=&quot;#一、数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、数据结构&quot;&gt;&lt;/a&gt;一、数据结构&lt;/h2&gt;&lt;p&gt;HashMap中的数据结构是数组+单链表的组合，以键值对(key-value)的形式存储元素的，通过put()和get()方法储存和获取对象。
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="HashMap" scheme="http://dijia478.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>request和response中文乱码问题后台处理办法</title>
    <link href="http://dijia478.cn//blog/2014/12/19/2014-12-19-request%E5%92%8Cresponse%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%90%8E%E5%8F%B0%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/"/>
    <id>http://dijia478.cn//blog/2014/12/19/2014-12-19-request和response中文乱码问题后台处理办法/</id>
    <published>2014-12-19T12:57:17.000Z</published>
    <updated>2017-12-31T12:58:00.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="request接收参数的中文乱码的处理："><a href="#request接收参数的中文乱码的处理：" class="headerlink" title="request接收参数的中文乱码的处理："></a>request接收参数的中文乱码的处理：</h2><h3 id="GET："><a href="#GET：" class="headerlink" title="GET："></a>GET：</h3><p>方法一：使用String的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> String(request.getParameter(<span class="string">"传过来的name"</span>).getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>方法二：修改tomcat7的默认编码方式，server.xml中端口号那项添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"50000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="POST："><a href="#POST：" class="headerlink" title="POST："></a>POST：</h3><p>方法一：设置request的缓冲区的编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p>方法二：使用spring的编码过滤器，在web.xml中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="response输出中文的乱码问题："><a href="#response输出中文的乱码问题：" class="headerlink" title="response输出中文的乱码问题："></a>response输出中文的乱码问题：</h2><h3 id="字符流输出中文："><a href="#字符流输出中文：" class="headerlink" title="字符流输出中文："></a>字符流输出中文：</h3><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置浏览器字符集编码. </span></span><br><span class="line">response.setHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"><span class="comment">// 设置response的缓冲区的编码.</span></span><br><span class="line">response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p>方法二：建议使用： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br></pre></td></tr></table></figure><h3 id="字节流输出中文：（实际中不会用）"><a href="#字节流输出中文：（实际中不会用）" class="headerlink" title="字节流输出中文：（实际中不会用）"></a>字节流输出中文：（实际中不会用）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字节流的方式输出中文：</span></span><br><span class="line">ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line"><span class="comment">// 设置浏览器默认打开的时候采用的字符集</span></span><br><span class="line">response.setHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"><span class="comment">// 设置中文转成字节数组字符集编码</span></span><br><span class="line">outputStream.write(<span class="string">"中文"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;request接收参数的中文乱码的处理：&quot;&gt;&lt;a href=&quot;#request接收参数的中文乱码的处理：&quot; class=&quot;headerlink&quot; title=&quot;request接收参数的中文乱码的处理：&quot;&gt;&lt;/a&gt;request接收参数的中文乱码的处理：&lt;/h2&gt;&lt;h3 id=&quot;GET：&quot;&gt;&lt;a href=&quot;#GET：&quot; class=&quot;headerlink&quot; title=&quot;GET：&quot;&gt;&lt;/a&gt;GET：&lt;/h3&gt;&lt;p&gt;方法一：使用String的构造方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(request.getParameter(&lt;span class=&quot;string&quot;&gt;&quot;传过来的name&quot;&lt;/span&gt;).getBytes(&lt;span class=&quot;string&quot;&gt;&quot;ISO-8859-1&quot;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="中文乱码" scheme="http://dijia478.cn/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>服务器获取浏览器发送请求中的cookies，选取自己需要的cookie</title>
    <link href="http://dijia478.cn//blog/2014/12/01/2014-12-01-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84cookies,%E9%80%89%E5%8F%96%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84cookie/"/>
    <id>http://dijia478.cn//blog/2014/12/01/2014-12-01-服务器获取浏览器发送请求中的cookies,选取自己需要的cookie/</id>
    <published>2014-12-01T02:13:54.000Z</published>
    <updated>2017-12-31T12:37:55.972Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String cookieName = “userID”;  <span class="comment">// 设置自己需要的cookie名</span></span><br><span class="line">Cookie cookies[] = request.getCookies();  <span class="comment">// 获取请求中的所有cookie</span></span><br><span class="line"><span class="keyword">if</span> (cookies!=<span class="keyword">null</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cookies.length;i++)  <span class="comment">// 遍历</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Cookie cookie = cookies[i];  </span><br><span class="line">        <span class="keyword">if</span> (cookieName.equals(cookie.getName()))   </span><br><span class="line">            doSomethingWith(cookie.getValue());  <span class="comment">// 用找的cookie去做你需要它做的事</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Java" scheme="http://dijia478.cn/categories/Java/"/>
    
    
      <category term="cookie" scheme="http://dijia478.cn/tags/cookie/"/>
    
  </entry>
  
</feed>
