<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dijia478-刘力源</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dijia478.cn/"/>
  <updated>2017-12-30T04:35:08.527Z</updated>
  <id>http://dijia478.cn/</id>
  
  <author>
    <name>dijia478</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程相关问题汇总</title>
    <link href="http://dijia478.cn//blog/2017/12/30/2017-12-30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://dijia478.cn//blog/2017/12/30/2017-12-30-多线程/</id>
    <published>2017-12-30T02:18:18.000Z</published>
    <updated>2017-12-30T04:35:08.527Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><blockquote><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。</p></blockquote></li></ol><a id="more"></a><ol><li><h4 id="多线程有什么用？"><a href="#多线程有什么用？" class="headerlink" title="多线程有什么用？"></a>多线程有什么用？</h4><blockquote><ul><li><p>发挥多核CPU的优势<br>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p></li><li><p>防止阻塞<br>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p></li><li><p>便于建模<br>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p></li></ul></blockquote></li><li><h4 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h4><blockquote><p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p></blockquote></li><li><h4 id="如何在Java中实现多线程？"><a href="#如何在Java中实现多线程？" class="headerlink" title="如何在Java中实现多线程？"></a>如何在Java中实现多线程？</h4><blockquote><p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程，但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类，或者直接实现Runnable接口来重写run方法实现线程。至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p></blockquote></li><li><h4 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h4><blockquote><p>这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。</p></blockquote></li><li><h4 id="Thread-类中的start和-run方法有什么区别？"><a href="#Thread-类中的start和-run方法有什么区别？" class="headerlink" title="Thread 类中的start和 run方法有什么区别？"></a>Thread 类中的start和 run方法有什么区别？</h4><blockquote><p>start方法被用来启动新创建的线程，只有调用了start方法，才会表现出多线程的特性，而且start内部调用了run方法，不同线程的run方法里面的代码交替执行，这和直接调用run方法的效果不一样。</p><p>当你调用run方法的时候，只会是在原来的线程中调用，没有新的线程启动，start方法才会启动新线程。如果只是调用run方法，那么代码还是同步执行的，必须等待一个线程的run方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run方法里面的代码。</p></blockquote></li><li><h4 id="Java中Runnable和Callable有什么不同？"><a href="#Java中Runnable和Callable有什么不同？" class="headerlink" title="Java中Runnable和Callable有什么不同？"></a>Java中Runnable和Callable有什么不同？</h4><blockquote><p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call方法可以返回值（是一个泛型）和抛出异常，返回装载有计算结果的Future对象。和Future、FutureTask配合可以用来获取多线程执行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。而Runnable接口中的run方法的返回值是void，它做的事情只是纯粹地去执行run方法中的代码而已。</p></blockquote></li><li><h4 id="Java中CyclicBarrier-和-CountDownLatch有什么不同？"><a href="#Java中CyclicBarrier-和-CountDownLatch有什么不同？" class="headerlink" title="Java中CyclicBarrier 和 CountDownLatch有什么不同？"></a>Java中CyclicBarrier 和 CountDownLatch有什么不同？</h4><blockquote><p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。</p><p>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务<br>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p></blockquote></li><li><h4 id="Java中如何停止一个线程？"><a href="#Java中如何停止一个线程？" class="headerlink" title="Java中如何停止一个线程？"></a>Java中如何停止一个线程？</h4><blockquote><p>Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop, suspend和 resume的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run或者 call方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run方法的循环或者是取消任务来中断线程。</p></blockquote></li><li><h4 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h4><blockquote><p>简单的说，如果异常没有被捕获，该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException方法进行处理。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。</p></blockquote></li><li><h4 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h4><blockquote><p>你可以通过共享对象来实现这个目的，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待.或者是使用像阻塞队列这样并发的数据结构，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p></blockquote></li><li><h4 id="什么是线程安全？Vector是一个线程安全类吗？"><a href="#什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="什么是线程安全？Vector是一个线程安全类吗？"></a>什么是线程安全？Vector是一个线程安全类吗？</h4><blockquote><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。简单来说就是，如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><ul><li><p>不可变<br>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p></li><li><p>绝对线程安全<br>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p></li><li><p>相对线程安全<br>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p></li><li><p>线程非安全<br>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p></li></ul></blockquote></li><li><h4 id="如何强制启动一个线程？"><a href="#如何强制启动一个线程？" class="headerlink" title="如何强制启动一个线程？"></a>如何强制启动一个线程？</h4><blockquote><p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p></blockquote></li><li><h4 id="Java多线程中调用wait和-sleep方法有什么不同？"><a href="#Java多线程中调用wait和-sleep方法有什么不同？" class="headerlink" title="Java多线程中调用wait和 sleep方法有什么不同？"></a>Java多线程中调用wait和 sleep方法有什么不同？</h4><blockquote><p>Java程序中wait和sleep都可以用来放弃CPU一定的时间，都会造成某种形式的暂停。<br>wait方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁。<br>而sleep方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。<br>如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器。</p></blockquote></li><li><h4 id="Thread-sleep-0-的作用是什么？"><a href="#Thread-sleep-0-的作用是什么？" class="headerlink" title="Thread.sleep(0.的作用是什么？"></a>Thread.sleep(0.的作用是什么？</h4><blockquote><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0.手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p></blockquote></li><li><h4 id="怎么唤醒一个阻塞的线程？"><a href="#怎么唤醒一个阻塞的线程？" class="headerlink" title="怎么唤醒一个阻塞的线程？"></a>怎么唤醒一个阻塞的线程？</h4><blockquote><p>如果线程是因为调用了wait、sleep或者join方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p></blockquote></li><li><h4 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h4><blockquote><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p></blockquote></li><li><h4 id="什么是线程池？-为什么要使用它？"><a href="#什么是线程池？-为什么要使用它？" class="headerlink" title="什么是线程池？ 为什么要使用它？"></a>什么是线程池？ 为什么要使用它？</h4><blockquote><p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p></blockquote></li><li><h4 id="如果你提交任务时，线程池队列已满，这时会发生什么？"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么？"></a>如果你提交任务时，线程池队列已满，这时会发生什么？</h4><blockquote><p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit方法将会抛出一个RejectedExecutionException异常。如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p></blockquote></li><li><h4 id="Java线程池中submit和-execute方法有什么区别？"><a href="#Java线程池中submit和-execute方法有什么区别？" class="headerlink" title="Java线程池中submit和 execute方法有什么区别？"></a>Java线程池中submit和 execute方法有什么区别？</h4><blockquote><p>两个方法都可以向线程池提交任务，execute方法的返回类型是void，它定义在Executor接口中, 而submit方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p></blockquote></li><li><h4 id="Java中用到的线程调度算法是什么？"><a href="#Java中用到的线程调度算法是什么？" class="headerlink" title="Java中用到的线程调度算法是什么？"></a>Java中用到的线程调度算法是什么？</h4><blockquote><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p></blockquote></li><li><h4 id="Java内存模型是什么？"><a href="#Java内存模型是什么？" class="headerlink" title="Java内存模型是什么？"></a>Java内存模型是什么？</h4><blockquote><p>Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它定义了一种多线程访问Java内存的规范，在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。我简单总结一下Java内存模型的几部分内容：</p><ul><li>Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</li><li>定义了几个原子操作，用于操作主内存和工作内存中的变量</li><li>定义了volatile变量的使用规则</li><li>happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</li></ul><p>我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p></blockquote></li><li><h4 id="Java中的volatile-变量是什么？"><a href="#Java中的volatile-变量是什么？" class="headerlink" title="Java中的volatile 变量是什么？"></a>Java中的volatile 变量是什么？</h4><blockquote><p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。volatile关键字的作用主要有两个：</p><p>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据<br>代码底层执行不像我们看到的高级语言—Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率<br>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p></blockquote></li><li><h4 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h4><blockquote><p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p></blockquote></li><li><h4 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的?"></a>线程类的构造方法、静态块是被哪个线程调用的?</h4><blockquote><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。<br>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><ul><li>Thread2的构造方法、静态块是main线程调用的，Thread2的run方法是Thread2自己调用的</li><li>Thread1的构造方法、静态块是Thread2调用的，Thread1的run方法是Thread1自己调用的</li></ul></blockquote></li><li><h4 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h4><blockquote><p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。</p></blockquote></li><li><h4 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h4><blockquote><ul><li>乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</li><li>悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</li></ul></blockquote></li><li><h4 id="什么是自旋？"><a href="#什么是自旋？" class="headerlink" title="什么是自旋？"></a>什么是自旋？</h4><blockquote><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p></blockquote></li><li><h4 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h4><blockquote><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p></blockquote></li><li><h4 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h4><blockquote><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。<br>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。<br>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p></blockquote></li><li><h4 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h4><blockquote><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p></blockquote></li><li><h4 id="什么是FutureTask？"><a href="#什么是FutureTask？" class="headerlink" title="什么是FutureTask？"></a>什么是FutureTask？</h4><blockquote><p>在Java并发程序中FutureTask表示一个可以取消的异步运算任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务进行启动和取消运算、查询运算是否完成和取回运算结果等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是实现了Runnable接口所以它可以提交给Executor线程池来执行。</p></blockquote></li><li><h4 id="不可变对象对多线程有什么帮助？"><a href="#不可变对象对多线程有什么帮助？" class="headerlink" title="不可变对象对多线程有什么帮助？"></a>不可变对象对多线程有什么帮助？</h4><blockquote><p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p></blockquote></li><li><h4 id="Java中什么是竞态条件？-举个例子说明。"><a href="#Java中什么是竞态条件？-举个例子说明。" class="headerlink" title="Java中什么是竞态条件？ 举个例子说明。"></a>Java中什么是竞态条件？ 举个例子说明。</h4><blockquote><p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理。</p></blockquote></li><li><h4 id="Java中notify-和-notifyAll有什么区别？"><a href="#Java中notify-和-notifyAll有什么区别？" class="headerlink" title="Java中notify 和 notifyAll有什么区别？"></a>Java中notify 和 notifyAll有什么区别？</h4><blockquote><p>这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p></blockquote></li><li><h4 id="为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><blockquote><p>这是个设计相关的问题，它考察的是程序员对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait方法就有意义了。如果wait方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p></blockquote></li><li><h4 id="为什么wait方法和notify-notifyAll方法要在同步块中调用？"><a href="#为什么wait方法和notify-notifyAll方法要在同步块中调用？" class="headerlink" title="为什么wait方法和notify/notifyAll方法要在同步块中调用？"></a>为什么wait方法和notify/notifyAll方法要在同步块中调用？</h4><blockquote><p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p></blockquote></li><li><h4 id="wait方法和notify-notifyAll方法在放弃对象监视器时有什么区别？"><a href="#wait方法和notify-notifyAll方法在放弃对象监视器时有什么区别？" class="headerlink" title="wait方法和notify/notifyAll方法在放弃对象监视器时有什么区别？"></a>wait方法和notify/notifyAll方法在放弃对象监视器时有什么区别？</h4><blockquote><p>wait方法立即释放对象监视器，notify/notifyAll方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p></blockquote></li><li><h4 id="多线程中的忙循环是什么"><a href="#多线程中的忙循环是什么" class="headerlink" title="多线程中的忙循环是什么?"></a>多线程中的忙循环是什么?</h4><blockquote><p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait, sleep或 yield它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p></blockquote></li><li><h4 id="怎么检测一个线程是否持有对象监视器？"><a href="#怎么检测一个线程是否持有对象监视器？" class="headerlink" title="怎么检测一个线程是否持有对象监视器？"></a>怎么检测一个线程是否持有对象监视器？</h4><blockquote><p>我也是在网上看到一篇文章才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj.方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。</p></blockquote></li><li><h4 id="Java中interrupted-和-isInterruptedd方法的区别？"><a href="#Java中interrupted-和-isInterruptedd方法的区别？" class="headerlink" title="Java中interrupted 和 isInterruptedd方法的区别？"></a>Java中interrupted 和 isInterruptedd方法的区别？</h4><blockquote><p>interrupted和 isInterrupted的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p></blockquote></li><li><h4 id="为什么你应该在循环中检查等待条件"><a href="#为什么你应该在循环中检查等待条件" class="headerlink" title="为什么你应该在循环中检查等待条件?"></a>为什么你应该在循环中检查等待条件?</h4><blockquote><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p></blockquote></li><li><h4 id="Java中的同步集合与并发集合有什么区别？"><a href="#Java中的同步集合与并发集合有什么区别？" class="headerlink" title="Java中的同步集合与并发集合有什么区别？"></a>Java中的同步集合与并发集合有什么区别？</h4><blockquote><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p></blockquote></li><li><h4 id="Java中ConcurrentHashMap的并发度是什么？"><a href="#Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="Java中ConcurrentHashMap的并发度是什么？"></a>Java中ConcurrentHashMap的并发度是什么？</h4><blockquote><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数segment的大小，默认值为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这样在多线程情况下也能避免争用。这也是ConcurrentHashMap对Hashtable的最大优势，Hashtable不能同时有两条线程获取Hashtable中的数据。</p></blockquote></li><li><h4 id="Java中堆和栈有什么不同？"><a href="#Java中堆和栈有什么不同？" class="headerlink" title="Java中堆和栈有什么不同？"></a>Java中堆和栈有什么不同？</h4><blockquote><p>为什么把这个问题归类在多线程和并发里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p></blockquote></li><li><h4 id="生产者消费者模型的作用是什么？"><a href="#生产者消费者模型的作用是什么？" class="headerlink" title="生产者消费者模型的作用是什么？"></a>生产者消费者模型的作用是什么？</h4><blockquote><p>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p></blockquote></li><li><h4 id="如何写代码来解决生产者消费者问题？"><a href="#如何写代码来解决生产者消费者问题？" class="headerlink" title="如何写代码来解决生产者消费者问题？"></a>如何写代码来解决生产者消费者问题？</h4><blockquote><p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型。</p></blockquote></li><li><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><blockquote><p>Java多线程中的死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul></blockquote></li><li><h4 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h4><blockquote><ul><li>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁</li><li>让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实</li><li>设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量</li><li>既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后变回返回一个失败信息</li></ul></blockquote></li><li><h4 id="Java中活锁和死锁有什么区别？"><a href="#Java中活锁和死锁有什么区别？" class="headerlink" title="Java中活锁和死锁有什么区别？"></a>Java中活锁和死锁有什么区别？</h4><blockquote><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p></blockquote></li><li><h4 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h4><blockquote><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我看到一本书上写到。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p></blockquote></li><li><h4 id="你如何在Java中获取线程堆栈？"><a href="#你如何在Java中获取线程堆栈？" class="headerlink" title="你如何在Java中获取线程堆栈？"></a>你如何在Java中获取线程堆栈？</h4><blockquote><p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p></blockquote></li><li><h4 id="JVM中哪个参数是用来控制线程的栈堆栈小的？"><a href="#JVM中哪个参数是用来控制线程的栈堆栈小的？" class="headerlink" title="JVM中哪个参数是用来控制线程的栈堆栈小的？"></a>JVM中哪个参数是用来控制线程的栈堆栈小的？</h4><blockquote><p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。</p></blockquote></li><li><h4 id="Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="Java中synchronized 和 ReentrantLock 有什么不同？"></a>Java中synchronized 和 ReentrantLock 有什么不同？</h4><blockquote><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点，比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。ReentrantLock 类实现了 Lock接口，提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量扩展性。</p><p>ReentrantLock比synchronized的扩展性体现在几点上：</p><ul><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</li></ul></blockquote></li><li><h4 id="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h4><blockquote><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1.，这样T1就会先完成而T3最后完成。</p></blockquote></li><li><h4 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h4><blockquote><p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p></blockquote></li><li><h4 id="Java中Semaphore是什么？"><a href="#Java中Semaphore是什么？" class="headerlink" title="Java中Semaphore是什么？"></a>Java中Semaphore是什么？</h4><blockquote><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p></blockquote></li><li><h4 id="Semaphore有什么作用？"><a href="#Semaphore有什么作用？" class="headerlink" title="Semaphore有什么作用？"></a>Semaphore有什么作用？</h4><blockquote><p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p></blockquote></li><li><h4 id="Swing是线程安全的吗？-为什么？"><a href="#Swing是线程安全的吗？-为什么？" class="headerlink" title="Swing是线程安全的吗？ 为什么？"></a>Swing是线程安全的吗？ 为什么？</h4><blockquote><p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。</p></blockquote></li><li><h4 id="Swing-API中那些方法是线程安全的？"><a href="#Swing-API中那些方法是线程安全的？" class="headerlink" title="Swing API中那些方法是线程安全的？"></a>Swing API中那些方法是线程安全的？</h4><blockquote><p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p></blockquote></li><li><h4 id="Java中invokeAndWait-和-invokeLater有什么区别？"><a href="#Java中invokeAndWait-和-invokeLater有什么区别？" class="headerlink" title="Java中invokeAndWait 和 invokeLater有什么区别？"></a>Java中invokeAndWait 和 invokeLater有什么区别？</h4><blockquote><p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。</p></blockquote></li><li><h4 id="如何在Java中创建Immutable对象？"><a href="#如何在Java中创建Immutable对象？" class="headerlink" title="如何在Java中创建Immutable对象？"></a>如何在Java中创建Immutable对象？</h4><blockquote><p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p></blockquote></li><li><h4 id="Java中的ReadWriteLock是什么？"><a href="#Java中的ReadWriteLock是什么？" class="headerlink" title="Java中的ReadWriteLock是什么？"></a>Java中的ReadWriteLock是什么？</h4><blockquote><p>ReadWriteLock是Java 5 中新增的一个接口，一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p></blockquote></li><li><h4 id="单例模式的双检锁是什么？"><a href="#单例模式的双检锁是什么？" class="headerlink" title="单例模式的双检锁是什么？"></a>单例模式的双检锁是什么？</h4><blockquote><p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。可以参考我的这篇文章<a href="http://www.cnblogs.com/dijia478/p/7978725.html" target="_blank" rel="noopener">http://www.cnblogs.com/dijia478/p/7978725.html</a></p></blockquote></li><li><h4 id="如何在Java中创建线程安全的Singleton？"><a href="#如何在Java中创建线程安全的Singleton？" class="headerlink" title="如何在Java中创建线程安全的Singleton？"></a>如何在Java中创建线程安全的Singleton？</h4><blockquote><p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。</p></blockquote></li><li><h4 id="什么是多线程的上下文切换？"><a href="#什么是多线程的上下文切换？" class="headerlink" title="什么是多线程的上下文切换？"></a>什么是多线程的上下文切换？</h4><blockquote><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p></blockquote></li><li><h4 id="写出3条你遵循的多线程最佳实践"><a href="#写出3条你遵循的多线程最佳实践" class="headerlink" title="写出3条你遵循的多线程最佳实践"></a>写出3条你遵循的多线程最佳实践</h4><blockquote><p>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p><ul><li><p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p></li><li><p>避免锁定和缩小同步的范围</p></li></ul><p>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p><ul><li>多用同步类少用wait 和 notify</li></ul><p>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p><ul><li>多用并发集合少用同步集合</li></ul><p>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</p></blockquote></li><li><h4 id="Java中的fork-join框架是什么？"><a href="#Java中的fork-join框架是什么？" class="headerlink" title="Java中的fork join框架是什么？"></a>Java中的fork join框架是什么？</h4><blockquote><p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。</p></blockquote></li><li><h4 id="Java中如何获取到线程dump文件？"><a href="#Java中如何获取到线程dump文件？" class="headerlink" title="Java中如何获取到线程dump文件？"></a>Java中如何获取到线程dump文件？</h4><blockquote><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><ul><li>获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</li><li>打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</li></ul><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。</p></blockquote></li><li><h4 id="Linux环境下如何查找哪个线程使用CPU最长"><a href="#Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="Linux环境下如何查找哪个线程使用CPU最长?"></a>Linux环境下如何查找哪个线程使用CPU最长?</h4><blockquote><p>这是一个比较偏实践的问题，可以这么做：</p><ul><li>获取项目的pid，jps或者ps -ef | grep java</li><li>top -H -p pid，顺序不能改变</li></ul><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号。<br>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。<br>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p></blockquote></li><li><h4 id="Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？"><a href="#Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？" class="headerlink" title="Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？"></a>Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</h4><blockquote><ul><li>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</li><li>CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。</li></ul></blockquote></li><li><h4 id="同步方法和同步块，哪个是更好的选择"><a href="#同步方法和同步块，哪个是更好的选择" class="headerlink" title="同步方法和同步块，哪个是更好的选择?"></a>同步方法和同步块，哪个是更好的选择?</h4><blockquote><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。<br>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p></blockquote></li><li><h4 id="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"><a href="#高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"></a>高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h4><blockquote><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><ul><li>高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</li><li>并发不高、任务执行时间长的业务要区分开看：</li><li>假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</li><li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li><li>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考第二条。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li></ul></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;什么是线程？&quot;&gt;&lt;a href=&quot;#什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程？&quot;&gt;&lt;/a&gt;什么是线程？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="http://dijia478.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何抽取代码后，在父类实例化泛型的问题</title>
    <link href="http://dijia478.cn//blog/2017/08/30/2017-12-18-%E7%88%B6%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B3%9B%E5%9E%8B/"/>
    <id>http://dijia478.cn//blog/2017/08/30/2017-12-18-父类实例化泛型/</id>
    <published>2017-08-30T13:10:45.000Z</published>
    <updated>2017-12-30T04:33:53.642Z</updated>
    
    <content type="html"><![CDATA[<p>代码背景：有大量的action类中需要使用模型驱动，所以会抽取公共部分代码，</p><p>但由于action类要实现ModelDriven<t>接口，抽取成BaseAction里面的泛型T如何在子类实例化的问题。<a id="more"></a></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽取Action的公共代码 ，简化开发</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dijia478</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0，2017-8-30 20:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 模型驱动 */</span></span><br><span class="line">    <span class="keyword">protected</span> T model;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器 完成model实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造子类Action对象 ，获取继承父类型的泛型</span></span><br><span class="line">        <span class="comment">// AreaAction extends BaseAction&lt;Area&gt;</span></span><br><span class="line">        <span class="comment">// BaseAction&lt;Area&gt;</span></span><br><span class="line">        Type genericSuperclass = <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">// 获取类型第一个泛型参数</span></span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">        Class&lt;T&gt; modelClass = (Class&lt;T&gt;) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            model = modelClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"模型构造失败..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是通过构造器来实例化泛型T的，子类要继承BaseAction，加载子类的时候，子类构造默认会调用supper();，所以会将泛型T实例化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码背景：有大量的action类中需要使用模型驱动，所以会抽取公共部分代码，&lt;/p&gt;
&lt;p&gt;但由于action类要实现ModelDriven&lt;t&gt;接口，抽取成BaseAction里面的泛型T如何在子类实例化的问题。
    
    </summary>
    
    
      <category term="泛型" scheme="http://dijia478.cn/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://dijia478.cn//blog/2016/05/13/2016-05-13-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://dijia478.cn//blog/2016/05/13/2016-05-13-Linux常用命令/</id>
    <published>2016-05-13T04:32:56.000Z</published>
    <updated>2017-12-31T12:04:28.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、系统目录结构"><a href="#一、系统目录结构" class="headerlink" title="一、系统目录结构"></a>一、系统目录结构</h2><p>约定俗成：</p><p>  bin (binaries)存放二进制可执行文件<br>  etc (etcetera)存放系统配置文件<br>  usr (unix shared resources)用于存放共享的系统资源<br>  home 存放用户文件的根目录<br>  root 超级用户目录<br><a id="more"></a><br>  sbin (super user binaries)存放二进制可执行文件，只有root才能访问<br>  dev (devices)用于存放设备文件<br>  lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块<br>  mnt (mount)系统管理员安装临时文件系统的安装点<br>  boot 存放用于系统引导时使用的各种文件<br>  tmp (temporary)用于存放各种临时文件<br>  var (variable)用于存放运行时需要改变数据的文件<br><img src="linux01.png" alt=""></p><h2 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h2><p><strong>加粗命令为本人比较常用的命令（会经常更新）</strong></p><h3 id="1-目录操作"><a href="#1-目录操作" class="headerlink" title="1.目录操作"></a>1.目录操作</h3><p>相对路径和绝对路径说明：</p><p>现在在/home/dijia478/下<br>./a/b.txt和a/b.txt都表示相对路径，当前目录下的a文件夹下的b.txt文件<br>/home/dijia478/a/b.txt表示绝对路径，根目录下的home文件夹下的dijia478文件夹下的a文件夹下的b.txt文件</p><p><strong>cd ./a    切换到当前目录的a文件夹</strong><br><strong>cd ..    切换到上一层目录</strong><br><strong>cd /    切换到系统根目录</strong><br><strong>cd ~    切换到用户主目录</strong><br><strong>cd -    切换到上一个所在目录</strong><br><strong>pwd    显示当前所在目录的绝对路径</strong></p><h3 id="2-查看文件列表"><a href="#2-查看文件列表" class="headerlink" title="2.查看文件列表"></a>2.查看文件列表</h3><p><strong>ls /path/    显示该目录所有文件或文件夹名</strong><br><strong>ls -a    显示所有文件或文件夹名（包含隐藏的）</strong><br><strong>ls -l    按列表显示所有文件或文件夹，缩写成ll</strong></p><p>ll -h    友好的显示文件大小（显示成K，MB，GB）</p><h3 id="3-创建和删除文件夹"><a href="#3-创建和删除文件夹" class="headerlink" title="3.创建和删除文件夹"></a>3.创建和删除文件夹</h3><p><strong>mkdir app    创建app文件夹</strong><br><strong>mkdir –p app2/test    级联创建aap2以及test文件夹</strong></p><p>rmdir app    删除app目文件夹（需要是空文件夹）</p><h3 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4.文件操作"></a>4.文件操作</h3><p><strong>rm a.txt    删除a.txt文件，删除需要用户确认，y/n</strong><br><strong>rm -f a.txt    不询问，直接删除a.txt文件</strong><br><strong>rm -r a    递归删除a文件夹（无论是否有内容）</strong><br><strong>rm -rf a    不询问递归删除a文件夹（慎用）</strong><br><strong>rm -rf *    删除当前目录下所有内容（最好别用）</strong><br><strong><em>rm -rf /\</em>    no 作 no die（Linux系统就玩完了）*</strong></p><p><strong>cp a.txt b.txt    将a.txt复制为b.txt文件</strong><br><strong>cp -r dir/ ../    将dir文件夹及子目录和文件复制到上一层目录中</strong></p><p><strong>mv a.txt ../    将a.txt文件移动到上一层目录中</strong><br><strong>mv a.txt b.txt    将a.txt文件重命名为b.txt</strong></p><p>touch a.txt    创建一个空的a.txt文件<br><strong>echo “good good study” &gt; a.txt    把”&gt;”左边的输出内容放到右边的文件里去，如果存在就覆盖，如果不存在就创建</strong><br><strong>vim a.txt    用文本编辑器编辑一个文件，如果不存在就创建</strong></p><h3 id="5-文件打包归档和压缩"><a href="#5-文件打包归档和压缩" class="headerlink" title="5.文件打包归档和压缩"></a>5.文件打包归档和压缩</h3><p>tar -cvf file.tar dirpath filepath    将dir文件夹和file文件在当前目录下打包成file.tar<br>tar –xvf file.tar    解包到当前目录</p><p>gzip file.tar    压缩文件或文件夹<br>gzip –d file.tar.gz    解压文件或文件夹</p><p><strong>tar -czvf file.tar.gz dirpath filepath    将dir文件夹和file文件在当前目录下打包并压缩成file.tar.gz</strong><br><strong>tar -xzvf file.tar.gz    解压并解包到当前目录下</strong><br><strong>tar -xzvf file.tar.gz -C /home/dijia478/    解压并解包到/home/dijia478/目录下</strong></p><p>常用参数：<br>-c：创建一个新tar文件<br>-v：显示运行过程的信息<br>-f：指定文件名<br>-z：调用gzip压缩命令进行压缩<br>-t：查看压缩文件的内容<br>-x：解开tar文件</p><p>zip test.txt.zip test.txt    也是打包并压缩<br>unzip test.txt.zip    解包并解包</p><p><strong>.rpm结尾的包，用rpm -ivh 命令安装</strong></p><h3 id="6-查看文本文件"><a href="#6-查看文本文件" class="headerlink" title="6.查看文本文件"></a>6.查看文本文件</h3><p><strong>cat a.txt    一次性显示整个文件内容</strong><br>more a.txt    可以分页看（翻页：空格,往回翻：b ，退出： q或者 Ctrl+C）<br><strong>less a.txt    不仅可以分页，还可以方便地搜索，回翻等操作（翻页：空格,往回翻：↑,往下翻:↓,退出：q或者 Ctrl+C）</strong></p><p>tail -10 a.txt    查看文件的尾部的10行<br><strong>tail -f user.log    实时刷新显示文件的尾部，这条命令对于观察调试程序的运行非常重要</strong></p><p>head -20 a.txt    查看文件的头部20行<br>注：ctrl+c 结束查看</p><h3 id="7-搜索查找命令"><a href="#7-搜索查找命令" class="headerlink" title="7.搜索查找命令"></a>7.搜索查找命令</h3><p><strong>grep ‘haha’ ./*    打印当前目录下所有文件中含有’haha’的地方（支持正则表达式）</strong><br>grep -c ‘haha’ ./*    显示匹配到的行数<br><strong>grep -r ‘haha’ ./*    对子目录也进行遍历搜索</strong><br>grep -l ‘haha’ ./*    只显示命中的文件名<br>grep -n ‘haha’ ./*    显示命中的行号<br>grep -ld skip ‘haha’ ./*     显示命中的文件名，不要搜索子目录</p><p>参数含义：<br>-r 递归搜索子目录<br>-l 只列出有匹配行的文件名<br>-n 列出匹配行的行号<br>-d skip 不搜索子文件夹</p><p>常用grep跟其他命令组合使用来查找我们关心的信息（管道）<br>示例：<br><strong>service –status-all | grep ‘httpd’    在当前系统所有服务中查找’httpd’</strong><br><strong>netstat -nltp | grep ‘22’    查找监听’22’端口的服务程序</strong><br><strong>ps –ef | grep java    查找系统中当前运行的java进程</strong></p><p><strong>find ./ -name ‘*.txt’    查找以.txt结尾的文件（会遍历当前目录）</strong><br><strong>find ./ -name ‘install*’    查找以install开头的文件或文件夹</strong><br>find ./ -type f    查找普通文件<br>find ./ -type l    查找连接文件(快捷方式)</p><h3 id="8-文本命令"><a href="#8-文本命令" class="headerlink" title="8.文本命令"></a>8.文本命令</h3><p>> 重定向输出，覆盖原有内容；<br>>&gt;    重定向输出，又追加功能；<br>cat /etc/passwd &gt; a.txt    将密码文件输出定向到a.txt中<br>cat /etc/passwd &gt;&gt; a.txt    输出并且追加<br>ifconfig &gt; ifconfig.txt    保存ip信息到文件中</p><p>wc -l a.txt    统计文本行数wc -w a.txt统计文本单词数wc -m a.txt统计文本字符数wc -c a.txt统计文本字节数</p><p><strong>vim编辑器，这里全都很常用</strong><br>vim filepath打开文件<br>按Esc键切换到命令行模式<br>切换到插入模式：<br>i在当前位置生前插入<br>I在当前行首插入<br>a在当前位置后插入<br>A在当前行尾插入<br>o在当前行之后插入一行<br>O在当前行之前插入一行<br>dd删除整行<br>7 dd向上删除7行<br>U回退(类似于windows 中 ctrl + z)<br>R替换<br>:（冒号）切换到底行模式<br>:q退出<br>:wq保存并退出（shift + zz也可以保存）<br>:q!不保存退出</p><h3 id="9-其他常用命令"><a href="#9-其他常用命令" class="headerlink" title="9.其他常用命令"></a>9.其他常用命令</h3><p><strong>echo $JAVA_HOME    输出变量JAVA_HOME的值</strong></p><p><strong>rpm -qa | grep tomcat    查看当前系统是否安装tomcat</strong><br><strong>rpm -e tomcat    卸载tomcat</strong><br>rpm 的其他附加命令<br>–force 强制操作 如强制安装删除等；<br>–requires 显示该包的依赖关系；<br><strong>–nodeps 忽略依赖关系并继续操作；</strong></p><p>whoami查询当前登陆的用户名<br>which ls查询ls命令的$PATH路径</p><p><strong>mkdir test &amp;&amp; cd test</strong><br>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。<br>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</p><h2 id="三、用户管理命令"><a href="#三、用户管理命令" class="headerlink" title="三、用户管理命令"></a>三、用户管理命令</h2><h3 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1.添加用户"></a>1.添加用户</h3><p>基本示例：<br>useradd user001</p><p>passwd 123456需要设置密码</p><p>参数手册：-u 指定组ID（uid）-g 指定所属的组名（gid）-G 指定多个组，用逗号“，”分开（Groups）-c 用户描述（comment）-d 指定用户目录-e 失效时间（expire date）</p><h3 id="2-删除用户"><a href="#2-删除用户" class="headerlink" title="2.删除用户"></a>2.删除用户</h3><p>userdel user002这样删除的时候，用户的主目录会被保留<br>userdel -r user002删除用户的同时删除用户的主目录</p><h3 id="3-修改用户属性"><a href="#3-修改用户属性" class="headerlink" title="3.修改用户属性"></a>3.修改用户属性</h3><p>指令：usermod<br>参数：<br>-l 修改用户名 （login）usermod -l a b（b改为a）<br>-g 修改组 usermod -g sys tom<br>-d 修改用户的宿主目录<br>-G 添加多个组 usermod -G sys,root tom<br>-L 锁定用户账号密码（Lock）<br>-U 解锁用户账号（Unlock）<br>示例：<br>usermod -l user002 user001将user001的登陆名改为user002<br>usermod -g root user002将user002的组改为root组<br>usermod -G hello1,hello2 user002给user002添加两个组hello1,hello2<br>usermod -d /home/dijia478 user002将user002的主目录改成/home/dijia478<br>（要事先创建dijia478目录，并且拷入环境变量文件）</p><h3 id="4-用户组管理"><a href="#4-用户组管理" class="headerlink" title="4.用户组管理"></a>4.用户组管理</h3><p>用户组相关属性：<br>每个用户至少属于一个用户组<br>（创建新用户时如果不指定所属组，则会自动创建并归属到一个跟用户名同名的组）<br>每个用户组可以包含多个用户<br>同一个用户组的用户享有该组共有的权限<br>用户组管理操作命令：<br>groupadd java创建用户组<br>groupdel hello2删除用户组<br>groupmod –n newname oldname修改用户组名称<br>groups user002查看用所属的组</p><h3 id="5-用户及用户组相关配置文件"><a href="#5-用户及用户组相关配置文件" class="headerlink" title="5.用户及用户组相关配置文件"></a>5.用户及用户组相关配置文件</h3><p>用户配置信息存放位置：<br>保存用户信息的文件：/etc/passwd<br>保存密码的文件：/etc/shadow</p><p>passwd文件示例：<br>user002:x:500:500:user002:/home/user002:/bin/bash<br>passwd文件各字段含义：<br>account:password:UID:GID:GECOS:directory:shell</p><p>shadow文件示例：<br>user002:$1$vRug41$UUxYzdP0i6s6wtUPieGDQ/:18617:0:99999:7:::<br>shadow文件各字段含义：</p><table><thead><tr><th>用户名</th><th>登陆系统的用户名</th></tr></thead><tbody><tr><td>密码</td><td>加密密码</td></tr><tr><td>最后一次修改时间</td><td>用户最后一次修改密码距现在的天数，从1970-1-1起</td></tr><tr><td>最小时间间隔</td><td>两次修改密码之间的最小天数</td></tr><tr><td>最大时间间隔</td><td>密码有效天数</td></tr><tr><td>警告时间</td><td>从系统警告到密码失效的天数</td></tr><tr><td>账号闲置时间</td><td>账号闲置时间</td></tr><tr><td>失效时间</td><td>密码失效的天数</td></tr><tr><td>标志</td><td>标志</td></tr></tbody></table><p>用户组配置信息存放位置：<br>保存用户组的文件：/etc/group<br>保存用户组密码的文件：/etc/gshadow（设置组管理员时才有用）</p><h3 id="6-其他的用户管理命令"><a href="#6-其他的用户管理命令" class="headerlink" title="6.其他的用户管理命令"></a>6.其他的用户管理命令</h3><p>id user002查看一个用户的UID和GIDsu user001切换到user001用户su - user001切换到user001用户，并且将环境也切换到user001用户的环境（推荐使用）exis退出当前shell（会退出当前登录用户）</p><h2 id="四、网络配置管理"><a href="#四、网络配置管理" class="headerlink" title="四、网络配置管理"></a>四、网络配置管理</h2><h3 id="1-网卡地址配置"><a href="#1-网卡地址配置" class="headerlink" title="1.网卡地址配置"></a>1.网卡地址配置</h3><p>检查网络连通性:<br><strong>ping 192.168.25.168    测试当前服务器和指定ip是否能进行网络通信</strong></p><p>查看ip地址<br><strong>ifconfig    查看所有网络设备的地址信息</strong><br>ifconfig eth0    查看指定的eth0以太网卡的地址信息</p><p>修改ip地址<br>ifconfig eth0 192.168.2.150 netmask 255.255.255.0</p><p>通过setup修改网络配置<br>在root权限下执行setup指令可以打开一个带菜单的伪图形界面来修改网络配置</p><p>通过配置文件修改ip地址<br>vi /etc/sysconfig/network-scripts/ifcfg-eth0 修改该配置文件即可改ip地址</p><h3 id="2-主机名配置管理"><a href="#2-主机名配置管理" class="headerlink" title="2.主机名配置管理"></a>2.主机名配置管理</h3><p>查看主机名<br>在shell提示符的@后有显示<br>或者用hostname指令打印出主机名</p><p>修改主机名<br>vi /etc/sysconfig/network    修改其中的hostname配置项:<br>HOSTNAME=newname<br>修改完成之后要重启服务器才能生效<br>要想立即生效，可以执行指令 hostname newname，然后注销重登陆</p><p>主机名-IP映射，服务器本地映射<br>服务器网络寻址时默认是现在本地的hosts文件中查找IP映射，通过修改hosts来映射局域网内部的主机名非常方便<br>实现方法，将局域网内的每一台主机的“hostnamip”写入每一台主机的hosts文件中：<br>vi /etc/hosts<br>192.168.2.150    user001-server-01<br>192.168.2.151    user001-server-02<br>192.168.2.152    user001-server-03</p><h3 id="3-网络服务启动与停止"><a href="#3-网络服务启动与停止" class="headerlink" title="3.网络服务启动与停止"></a>3.网络服务启动与停止</h3><p>列出系统所有应用服务状态：<br>service –status-all<br><strong>查看指定服务运行状态：</strong><br><strong>service servicename status</strong><br><strong>启动服务：</strong><br><strong>service servicename start</strong><br><strong>停止服务：</strong><br><strong>service servicename stop</strong></p><p><strong>列出所有服务的随机自起配置：</strong><br><strong>chkconfig –list</strong><br><strong>关闭服务的随机自起：</strong><br><strong>chkconfig servicename off</strong><br><strong>开启服务的随机自起：</strong><br><strong>chkconfig servicename on</strong></p><p>常用示例：<br><strong>重启网络服务：service network restart</strong><br><strong>停止httpd：service httpd stop</strong><br><strong>启动httpd：service httpd start</strong><br><strong>关闭防火墙服务：service iptables stop</strong><br><strong>关闭防火墙自动启动：chkconfig iptables off</strong></p><h3 id="4-查看网络连接信息"><a href="#4-查看网络连接信息" class="headerlink" title="4.查看网络连接信息"></a>4.查看网络连接信息</h3><p>指令：netstat<br>netstat常用示例：<br>netstat -natp<br><strong>netstat -nltp</strong><br>netstat -naup</p><p><strong>netstat -an | grep 3306    查询3306端口占用情况</strong></p><p>常用参数解释：<br>-a 显示所有连接和监听端口<br>-l 只显示监听进程<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化成数字。<br>-p 显示建立相关链接的程序名</p><p>lsof命令其实要比netstat强大<br>常用参数：<br>-i　显示所有连接<br>-i 6　仅获取IPv6流量<br>-iTCP 仅显示TCP连接<br>-i:8080　显示与8080端口相关的网络信息<br>-i@192.168.128.128　显示指定到192.168.128.128的连接<br>-i@192.168.128.128:22　显示基于主机与端口的连接<br>-i -sTCP:LISTEN　找出正等候连接的端口<br>-i -sTCP:ESTABLISHED　找出已建立的连接<br>-u 用户名　显示指定用户打开了什么<br>-u ^用户名 显示除指定用户以外的其它所有用户所做的事情<br>-p 10075 查看指定进程ID已打开的内容<br>其他用法：<br>kill -9 ‘lsof -t -u 用户名’    杀死指定用户所做的一切事情<br>lsof /var/log/messages/    显示与指定目录或文件交互的所有一切<br>lsof -u dijia478 -i @1.1.1.1    显示dijia478连接到1.1.1.1所做的一切</p><h2 id="五、常用系统管理命令"><a href="#五、常用系统管理命令" class="headerlink" title="五、常用系统管理命令"></a>五、常用系统管理命令</h2><h3 id="1-磁盘-内存使用信息查看"><a href="#1-磁盘-内存使用信息查看" class="headerlink" title="1.磁盘/内存使用信息查看"></a>1.磁盘/内存使用信息查看</h3><p><strong>df -h    查看磁盘空间状态信息</strong><br><strong>du -sh *    查看指定目录下所有子目录和文件的汇总大小</strong><br><strong>free    查看内存使用状况</strong></p><h3 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h3><p>top    查看实时刷新的系统进程信息<br>ps -ef    查看系统中当前瞬间的进程信息快照<br><strong>ps -ef | grep myshell    搜索myshell进程的信息</strong><br><strong>kill -9 pid    杀掉指定pid的进程（-9 表示强制杀死）</strong></p><h3 id="3-sudo权限的配置"><a href="#3-sudo权限的配置" class="headerlink" title="3.sudo权限的配置"></a>3.sudo权限的配置</h3><p>root用户因为具有不受限制的权限，使用不慎可能对系统造成不可估量的损害，因而，生产实际中，轻易不要使用su去切换到root的身份<br>如果普通用户需要使用一些系统级管理命令，可以使用sudo来执行，比如 sudo vim /etc/profile<br>给普通用户赋予sudo权限，配置方法如下：<br>例如，要给hadoop用户赋予sudo任何指令（或某条指定的命令）的权利，则编辑sudoers文件 vim /etc/sudoers<br>在其中加入需要赋予权限的用户<br>&gt;</p><blockquote><p>root        ALL=(ALL)    ALL<br>#让hadoop用户可以用root身份执行所有指令<br>hadoop    ALL=(ALL)    ALL<br>#让user002用户可以用root身份执行useradd,passwd命令<br>user002    ALL=(root)    /usr/sbin/useradd, /usr/bin/passwd</p></blockquote><p>检查是否生效:<br>[root@user001-server-01 user002]# sudo -lU user002<br>User user002 is not allowed to run sudo on user001-server-01.</p><h3 id="4-修改系统的默认启动级别"><a href="#4-修改系统的默认启动级别" class="headerlink" title="4.修改系统的默认启动级别"></a>4.修改系统的默认启动级别</h3><p>vim /etc/inittab</p><p>&gt;</p><blockquote><p>#   0 - halt (Do NOT set initdefault to this)<br>#   1 - Single user mode<br>#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)<br>#   3 - Full multiuser mode<br>#   4 - unused<br>#   5 - X11<br>#   6 - reboot (Do NOT set initdefault to this)<br>#<br>id:3:initdefault:<br>~</p></blockquote><p>用level 3 就启动全功能状态的命令行界面，5是图形界面。不要设置其他的，容易作死。<br>在命令行模式下，用startx可以手动启动图形界面(在服务器上操作)</p><h3 id="5-文件权限管理"><a href="#5-文件权限管理" class="headerlink" title="5.文件权限管理"></a>5.文件权限管理</h3><p><img src="linux02.png" alt=""></p><p>Linux三种文件类型：<br>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。<br>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。<br>设备文件： Linux系统把每一个设备都看成是一个文件<br>文件类型标识：<br>普通文件（-）<br>目录（d）<br>符号链接（l）<br>* 进入etc可以查看，相当于快捷方式<br>字符设备文件（c）<br>块设备文件（s）<br>套接字（s）<br>命名管道（p）</p><p>u 表示“用户（user）”，即文件或目录的所有者。<br>g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。<br>o 表示“其他（others）用户”。<br>a 表示“所有（all）用户”。它是系统默认值。<br>操作符号可以是：<br>+ 添加某个权限。<br>- 取消某个权限。<br>= 赋予给定权限并取消其他所有权限（如果有的话）。<br>设置mode所表示的权限可用下述字母的任意组合：<br>r 可读。<br>w 可写。<br>x 可执行。</p><p>文件权限管理：<br><strong>chmod u+rwx a.txt    为a.txt添加所属用户的rwx权限</strong><br>chmod 755 a.txt    为a.txt设置所属用户rwx权限，所属组rx权限，其他用户rx权限（r-4，w-2，x-1）<br>chmod u=rwx,g=rx,o=rx a.txt    （u代表所属用户 g代表所属组的成员用户 o代表其他用户）<br>chown user001:hello1 a.txt    将a.txt的所有者改成user001用户，所属组改成hello1组（需要root权限）<br>chown -R user001:hello1 dir    将dir文件夹的所有者改成user001用户，所属组改成hello1组（需要root权限）</p><h3 id="6-其他系统管理命令"><a href="#6-其他系统管理命令" class="headerlink" title="6.其他系统管理命令"></a>6.其他系统管理命令</h3><p>date “+%Y%m%d”按格式显示当前系统时间<br>date -s “2020-01-01 10:10:10”设置系统时间<br><strong>clear清屏幕(只是滚到上面看不到了)</strong><br>uname 显示系统信息<br>uname -a 显示本机详细信息。依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、系统目录结构&quot;&gt;&lt;a href=&quot;#一、系统目录结构&quot; class=&quot;headerlink&quot; title=&quot;一、系统目录结构&quot;&gt;&lt;/a&gt;一、系统目录结构&lt;/h2&gt;&lt;p&gt;约定俗成：&lt;/p&gt;
&lt;p&gt;  bin (binaries)存放二进制可执行文件&lt;br&gt;  etc (etcetera)存放系统配置文件&lt;br&gt;  usr (unix shared resources)用于存放共享的系统资源&lt;br&gt;  home 存放用户文件的根目录&lt;br&gt;  root 超级用户目录&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dijia478.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何正确的写出单例模式</title>
    <link href="http://dijia478.cn//blog/2015/04/18/2015-04-18-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%86%99%E5%87%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://dijia478.cn//blog/2015/04/18/2015-04-18-如何正确的写出单例模式/</id>
    <published>2015-04-18T15:55:26.000Z</published>
    <updated>2017-12-30T16:10:55.148Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。<a id="more"></a></p><h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p><h2 id="懒汉式，双重检验锁"><a href="#懒汉式，双重检验锁" class="headerlink" title="懒汉式，双重检验锁"></a>懒汉式，双重检验锁</h2><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">//Single Checked</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">//Double Checked</span></span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题。主要在于<code>instance = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><ol><li>给 instance 分配内存</li><li>调用 Singleton 的构造函数来初始化成员变量</li><li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li></ol><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p><h2 id="懒汉式，静态内部类-static-nested-class"><a href="#懒汉式，静态内部类-static-nested-class" class="headerlink" title="懒汉式，静态内部类 static nested class"></a>懒汉式，静态内部类 static nested class</h2><p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h2 id="饿汉式-static-final-field"><a href="#饿汉式-static-final-field" class="headerlink" title="饿汉式 static final field"></a>饿汉式 static final field</h2><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p><h2 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum"></a>枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。</p><p>就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。
    
    </summary>
    
    
      <category term="单例模式" scheme="http://dijia478.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.7中HashMap底层实现原理</title>
    <link href="http://dijia478.cn//blog/2015/03/13/2015-03-13-JDK1-7%E4%B8%ADHashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://dijia478.cn//blog/2015/03/13/2015-03-13-JDK1-7中HashMap底层实现原理/</id>
    <published>2015-03-13T10:14:32.000Z</published>
    <updated>2017-12-31T12:03:18.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p>HashMap中的数据结构是数组+单链表的组合，以键值对(key-value)的形式存储元素的，通过put()和get()方法储存和获取对象。<a id="more"></a></p><p><img src="HashMap01.png" alt="HashMap数据结构"></p><p>（蓝色方块表示Entry对象，横排红框表示数组table[ ]，纵排绿框表示哈希桶bucket【实际上是一个由Entry组成的链表，新加入的Entry放在链头，最先加入的放在链尾】）</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 初始容量，默认16 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 最大初始容量，2^30 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 负载因子，默认0.75，负载因子越小，hash冲突机率越低 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 初始化一个Entry的空数组 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将初始化好的空数组赋值给table，table数组是HashMap实际存储数据的地方，并不在EMPTY_TABLE数组中 */</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** HashMap实际存储的元素个数 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 临界值（HashMap 实际能存储的大小）,公式为(threshold = capacity * loadFactor) */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 负载因子 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** HashMap的结构被修改的次数，用于迭代器 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断设置的容量和负载因子合不合理</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 设置负载因子，临界值此时为容量大小，后面第一次put时由inflateTable(int toSize)方法计算设置</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>put()源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果table引用指向成员变量EMPTY_TABLE，那么初始化HashMap（设置容量、临界值，新的Entry数组引用）</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若“key为null”，则将该键值对添加到table[0]处，遍历该链表，如果有key为null，则将value替换。没有就创建新Entry对象放在链表表头</span></span><br><span class="line">    <span class="comment">// 所以table[0]的位置上，永远最多存储1个Entry对象，形成不了链表。key为null的Entry存在这里 </span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);  </span><br><span class="line">    <span class="comment">// 若“key不为null”，则计算该key的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);  </span><br><span class="line">    <span class="comment">// 搜索指定hash值在对应table中的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line">    <span class="comment">// 循环遍历table数组上的Entry对象，判断该位置上key是否已存在</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">// 哈希值相同并且对象相同</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            <span class="comment">// 如果这个key对应的键值对已经存在，就用新的value代替老的value，然后退出！</span></span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// table数组中没有key对应的键值对，就将key-value添加到table[i]处 </span></span><br><span class="line">    addEntry(hash, key, value, i);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们给put()方法传递键和值时，HashMap会由key来调用hash()方法，返回键的hash值，计算Index后用于找到bucket（哈希桶）的位置来储存Entry对象。</p><p>如果两个对象key的hash值相同，那么它们的bucket位置也相同，但equals()不相同，添加元素时会发生hash碰撞，也叫hash冲突，HashMap使用链表来解决碰撞问题。</p><p>分析源码可知，put()时，HashMap会先遍历table数组，用hash值和equals()判断数组中是否存在完全相同的key对象， 如果这个key对象在table数组中已经存在，就用新的value代替老的value。如果不存在，就创建一个新的Entry对象添加到table[ i ]处。</p><p>如果该table[ i ]已经存在其他元素，那么新Entry对象将会储存在bucket链表的表头，通过next指向原有的Entry对象，形成链表结构（hash碰撞解决方案）。</p><p>Entry数据结构源码如下（HashMap内部类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       <span class="comment">/** 指向下一个元素的引用 */</span></span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">       <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 构造方法为Entry赋值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">           value = v;</span><br><span class="line">           next = n;</span><br><span class="line">           key = k;</span><br><span class="line">           hash = h;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形成单链表的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Entry添加到数组bucketIndex位置对应的哈希桶中，并判断数组是否需要扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果数组长度大于等于容量×负载因子，并且要添加的位置为null</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 长度扩大为原数组的两倍，代码分析见下面扩容机制</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表中添加一个新的Entry对象在链表的表头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="HashMap02.png" alt="put方法执行过程"></p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>如果两个不同的key的hashcode相同，两个值对象储存在同一个bucket位置，要获取value，我们调用get()方法，HashMap会使用key的hashcode找到bucket位置，因为HashMap在链表中存储的是Entry键值对，所以找到bucket位置之后，会调用key的equals()方法，按顺序遍历链表的每个 Entry，直到找到想获取的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry 是最早放入该 bucket 中），那HashMap必须循环到最后才能找到该元素。</p><p>get()方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若key为null，遍历table[0]处的链表（实际上要么没有元素，要么只有一个Entry对象），取出key为null的value</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// 若key不为null，用key获取Entry对象</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="comment">// 若链表中找到的Entry不为null，返回该Entry中的value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">// 计算key在数组中对应位置，遍历该位置的链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 若key完全相同，返回链表中对应的Entry对象</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中没找到对应的key，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、hash算法"><a href="#三、hash算法" class="headerlink" title="三、hash算法"></a>三、hash算法</h2><p>我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 </p><p>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns index for hash code h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、性能问题"><a href="#四、性能问题" class="headerlink" title="四、性能问题"></a>四、性能问题</h2><p>HashMap有两个参数影响其性能：初始容量和负载因子。均可以通过构造方法指定大小。</p><p>容量capacity是HashMap中bucket哈希桶(Entry的链表)的数量，初始容量只是HashMap在创建时的容量，最大设置初始容量是2^30，默认初始容量是16（必须为2的幂），解释一下，当数组长度为2的n次幂的时候，不同的key通过indexFor()方法算得的数组位置相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，get()的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p><p>负载因子loadFactor是HashMap在其容量自动增加之前可以达到多满的一种尺度，默认值是0.75。</p><h3 id="扩容机制："><a href="#扩容机制：" class="headerlink" title="扩容机制："></a>扩容机制：</h3><p>当HashMapde的长度超出了加载因子与当前容量的乘积（默认16*0.75=12）时，通过调用resize方法重新创建一个原来HashMap大小的两倍的newTable数组，最大扩容到2^30+1，并将原先table的元素全部移到newTable里面，重新计算hash，然后再重新根据hash分配位置。这个过程叫作rehash，因为它调用hash方法找到新的bucket位置。</p><p>扩容机制源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 如果之前的HashMap已经扩充打最大了，那么就将临界值threshold设置为最大的int值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新传入的newCapacity创建新Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 用来将原先table的元素全部移到newTable里面，重新计算hash，然后再重新根据hash分配位置</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">// 再将newTable赋值给table</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 重新计算临界值，扩容公式在这儿（newCapacity * loadFactor）</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容问题："><a href="#扩容问题：" class="headerlink" title="扩容问题："></a>扩容问题：</h3><p>数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这个操作是极其消耗性能的。所以如果我们已经预知HashMap中元素的个数，那么预设初始容量能够有效的提高HashMap的性能。</p><p>重新调整HashMap大小，当多线程的情况下可能产生条件竞争。因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。</p><h2 id="五、线程安全"><a href="#五、线程安全" class="headerlink" title="五、线程安全"></a>五、线程安全</h2><p>HashMap是线程不安全的，在多线程情况下直接使用HashMap会出现一些莫名其妙不可预知的问题。在多线程下使用HashMap，有几种方案：</p><p>A.在外部包装HashMap，实现同步机制</p><p>B.使用Map m = Collections.synchronizedMap(new HashMap(…));实现同步（官方参考方案，但不建议使用，使用迭代器遍历的时候修改映射结构容易出错）</p><p>D.使用java.util.HashTable，效率最低（几乎被淘汰了）</p><p>E.使用java.util.concurrent.ConcurrentHashMap，相对安全，效率高（建议使用）</p><p>注意一个小问题，HashMap所有集合类视图所返回迭代器都是快速失败的(fail-fast)，在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的 remove 或 add 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。。因此，面对并发的修改，迭代器很快就会完全失败。</p><h2 id="六、关于JDK1-8的问题"><a href="#六、关于JDK1-8的问题" class="headerlink" title="六、关于JDK1.8的问题"></a>六、关于JDK1.8的问题</h2><p>JDK1.8的HashMap源码实现和1.7是不一样的，有很大不同，其底层数据结构也不一样，引入了红黑树结构。有网友测试过，JDK1.8HashMap的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表长度大于8的时候，HashMap会动态的将它替换成一个红黑树（JDK1.8引入红黑树大程度优化了HashMap的性能），这会将时间复杂度从O(n)降为O(logn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据结构&quot;&gt;&lt;a href=&quot;#一、数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、数据结构&quot;&gt;&lt;/a&gt;一、数据结构&lt;/h2&gt;&lt;p&gt;HashMap中的数据结构是数组+单链表的组合，以键值对(key-value)的形式存储元素的，通过put()和get()方法储存和获取对象。
    
    </summary>
    
    
      <category term="HashMap" scheme="http://dijia478.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>服务器获取浏览器发送请求中的cookies，选取自己需要的cookie</title>
    <link href="http://dijia478.cn//blog/2014/12/01/2014-12-01-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84cookies,%E9%80%89%E5%8F%96%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84cookie/"/>
    <id>http://dijia478.cn//blog/2014/12/01/2014-12-01-服务器获取浏览器发送请求中的cookies,选取自己需要的cookie/</id>
    <published>2014-12-01T02:13:54.000Z</published>
    <updated>2017-12-31T02:16:04.699Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String cookieName = “userID”;  <span class="comment">// 设置自己需要的cookie名</span></span><br><span class="line">Cookie cookies[] = request.getCookies();  <span class="comment">// 获取请求中的所有cookie</span></span><br><span class="line"><span class="keyword">if</span> (cookies!=<span class="keyword">null</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cookies.length;i++)  <span class="comment">// 遍历</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Cookie cookie = cookies[i];  </span><br><span class="line">        <span class="keyword">if</span> (cookieName.equals(cookie.getName()))   </span><br><span class="line">            doSomethingWith(cookie.getValue());  <span class="comment">// 用找的cookie去做你需要它做的事</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="cookie" scheme="http://dijia478.cn/tags/cookie/"/>
    
  </entry>
  
</feed>
